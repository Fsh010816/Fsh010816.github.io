{"meta":{"title":"Fsh","subtitle":"Fsh","description":"","author":"fsh","url":"http://Fsh010816.github.io","root":"/"},"pages":[{"title":"404","date":"2020-12-19T07:26:40.000Z","updated":"2020-12-19T07:27:00.079Z","comments":true,"path":"404/index.html","permalink":"http://fsh010816.github.io/404/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-12-19T07:23:23.000Z","updated":"2020-12-19T07:23:41.727Z","comments":true,"path":"friends/index.html","permalink":"http://fsh010816.github.io/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-12-19T07:15:58.000Z","updated":"2020-12-19T07:20:10.752Z","comments":true,"path":"categories/index.html","permalink":"http://fsh010816.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-12-19T07:20:51.000Z","updated":"2020-12-19T07:21:08.106Z","comments":true,"path":"contact/index.html","permalink":"http://fsh010816.github.io/contact/index.html","excerpt":"","text":""},{"title":"about","date":"2020-12-19T07:18:58.000Z","updated":"2020-12-19T07:19:41.315Z","comments":true,"path":"about/index.html","permalink":"http://fsh010816.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-12-19T07:18:26.000Z","updated":"2020-12-19T07:20:23.582Z","comments":true,"path":"tags/index.html","permalink":"http://fsh010816.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MySQL基础","slug":"MySQL基础","date":"2021-03-26T06:05:40.000Z","updated":"2021-03-26T13:01:06.636Z","comments":true,"path":"2021/03/26/mysql-ji-chu/","link":"","permalink":"http://fsh010816.github.io/2021/03/26/mysql-ji-chu/","excerpt":"","text":"# MySQL 基础","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"16-Java8新特性","slug":"16-Java8新特性","date":"2021-03-25T05:58:11.000Z","updated":"2021-03-25T13:27:22.531Z","comments":true,"path":"2021/03/25/16-java8-xin-te-xing/","link":"","permalink":"http://fsh010816.github.io/2021/03/25/16-java8-xin-te-xing/","excerpt":"","text":"# Java8 新特性 # Lambda 表达式的使用 1. 举例： (o1,o2) -&gt; Integer.compare (o1,o2); 2. 格式： -&gt; :lambda 操作符 或 箭头操作符 -&gt; 左边：lambda 形参列表 （其实就是接口中的抽象方法的形参列表） -&gt; 右边：lambda 体 （其实就是重写的抽象方法的方法体） 3.Lambda 表达式的使用：（分为 6 种情况介绍） 语法格式一：无参，无返回值 语法格式二：Lambda 需要一个参数，但是没有返回值。 语法格式三：数据类型可以省略，因为可由编译器推断得出，称为 “类型推断” 语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略 语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值 语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略 总结： -&gt; 左边：lambda 形参列表的参数类型可以省略 (类型推断)；如果 lambda 形参列表只有一个参数，其一对 () 也可以省略 -&gt; 右边：lambda 体应该使用一对 {} 包裹；如果 lambda 体只有一条执行语句（可能是 return 语句），省略这一对 {} 和 return 关键字 4.Lambda 表达式的本质：作为函数式接口的实例 5. 如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上使用 @FunctionalInterface 注解， 这样做可以检查它是否是一个函数式接口。 6. 所以以前用匿名实现类表示的现在都可以用 Lambda 表达式来写。 # 函数式接口 只包含一个抽象方法的接口，称为函数式接口 Lambda 表达式就是一个函数式接口的实例 所以以前用匿名实现类表示的现在都可以用 Lambda 表达式来写 /** * java内置的4大核心函数式接口 * * 消费型接口 Consumer&lt;T&gt; void accept(T t) * 供给型接口 Supplier&lt;T&gt; T get() * 函数型接口 Function&lt;T,R&gt; R apply(T t) * 断定型接口 Predicate&lt;T&gt; boolean test(T t) * */ # 方法引用与构造器引用 方法引用的使用 1. 使用情境：当要传递给 Lambda 体的操作，已经有实现的方法了，可以使用方法引用！ 2. 方法引用，本质上就是 Lambda 表达式，而 Lambda 表达式作为函数式接口的实例。所以方法引用，也是函数式接口的实例。 3. 使用格式： 类 (或对象) :: 方法名 4. 具体分为如下的三种情况： 情况 1 对象：：非静态方法 情况 2 类：：静态方法 情况 3 类：：非静态方法 5. 方法引用使用的要求：要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同！（针对于情况 1 和情况 2） 构造器引用: 格式：ClassName::new 和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。 抽象方法的返回值类型即为构造器所属的类的类型 数组引用： 格式： type [] :: new # 强大的 Stream API 1.Stream 关注的是对数据的运算，与 CPU 打交道 集合关注的是数据的存储，与内存打交道 ①Stream 自己不会存储元素。 ②Stream 不会改变源对象。相反，他们会返回一个持有结果的新 Stream。 ③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行 3.Stream 执行流程 ① Stream 的实例化 ② 一系列的中间操作（过滤、映射、…) ③ 终止操作 4. 说明： 4.1 一个中间操作链，对数据源的数据进行处理 4.2 一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用 创建 Stream 方式一：通过集合 List&lt;Employee&gt; employees = EmployeeData.getEmployees(); // default Stream&lt;E&gt; stream() : 返回一个顺序流 Stream&lt;Employee&gt; stream = employees.stream(); // default Stream&lt;E&gt; parallelStream() : 返回一个并行流 Stream&lt;Employee&gt; parallelStream = employees.parallelStream(); 创建 Stream 方式二：通过数组 int[] arr = new int[]{1,2,3,4,5,6}; //调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流 IntStream stream = Arrays.stream(arr); 创建 Stream 方式三：通过 Stream 的 of (), 通过显示值创建一个流。它可以接收任意数量的参数。 Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4, 5, 6); 创建 Stream 方式四：创建无限流 // 迭代 // public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) //遍历前10个偶数 Stream.iterate(0, t -&gt; t + 2).limit(10).forEach(System.out::println); // 生成 // public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s) Stream.generate(Math::random).limit(10).forEach(System.out::println); # Stream 的中间操作 1 - 筛选与切片 filter (Predicate p)—— 接收 Lambda ， 从流中排除某些元素。 limit (n)—— 截断流，使其元素不超过给定数量。 skip (n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit (n) 互补 distinct ()—— 筛选，通过流所生成元素的 hashCode () 和 equals () 去除重复元素 2 - 映射 map (Function f)—— 接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素。 flatMap (Function f)—— 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。 3 - 排序 sorted ()—— 自然排序 sorted (Comparator com)—— 定制排序 # 测试 Stream 的终止操作 1 - 匹配与查找 allMatch (Predicate p)—— 检查是否匹配所有元素。 anyMatch (Predicate p)—— 检查是否至少匹配一个元素。 noneMatch (Predicate p)—— 检查是否没有匹配的元素。 findFirst—— 返回第一个元素 findAny—— 返回当前流中的任意元素 count—— 返回流中元素的总个数 max (Comparator c)—— 返回流中最大值 min (Comparator c)—— 返回流中最小值 forEach (Consumer c)—— 内部迭代 // forEach(Consumer c)——内部迭代 employees.stream().forEach(System.out::println); //使用集合的遍历操作 employees.forEach(System.out::println); 2 - 归约 reduce (T identity, BinaryOperator)—— 可以将流中元素反复结合起来，得到一个值。返回 T reduce (BinaryOperator) —— 可以将流中元素反复结合起来，得到一个值。返回 Optional 3 - 收集 collect (Collector c)—— 将流转换为其他形式。接收一个 Collector 接口的实现，用于给 Stream 中元素做汇总的方法 Collector 接口中方法的实现决定了如何对流执行收集的操作 (如收集到 List、Set、Map) # Optional 类 Optional 类 (java.util.Optional) 是一个容器类，它可以保存类型 T 的值，代表这个值存在。或者仅仅保存 null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。 Optional.of (T t) : 创建一个 Optional 实例，t 必须非空； Optional.empty () : 创建一个空的 Optional 实例 Optional.ofNullable (T t)：t 可以为 null orElse (T t1): 如果单前的 Optional 内部封装的 t 是非空的，则返回内部的 t, 如果内部的 t 是空的，则返回 orElse () 方法中的参数 t1. get () 通常与 of () 方法搭配使用。用于获取内部的封装的数据 value","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"15-反射","slug":"15-反射","date":"2021-03-25T05:57:46.000Z","updated":"2021-03-25T12:33:36.937Z","comments":true,"path":"2021/03/25/15-fan-she/","link":"","permalink":"http://fsh010816.github.io/2021/03/25/15-fan-she/","excerpt":"","text":"# 反射 # 理解 Class 类并获取 Class 实例 关于 java.lang.Class 类的理解 ①. 类的加载过程： 程序经过 javac.exe 命令以后，会生成一个或多个字节码文件 (.class 结尾)。接着我们使用 java.exe 命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为 Class 的一个实例。 ②换句话说，Class 的实例就对应着一个运行时类。 ③加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。 ④加载完类之后，在堆内存的方法区中就产生了一个 Class 类型的对象（一个类只有一个 Class 对象），这个对象就包含了完整的类的结构信息。 ⑤一个 Class 对象对应的是一个加载到 JVM 中的一个.class 文件 ⑥一个加载的类在 JVM 中只会有一个 Class 实例 //获取Class的实例的方式（前三种方式需要掌握） @Test public void test3() throws ClassNotFoundException { //方式一：调用运行时类的属性：.class Class clazz1 = Person.class; System.out.println(clazz1); //方式二：通过运行时类的对象,调用getClass() Person p1 = new Person(); Class clazz2 = p1.getClass(); System.out.println(clazz2); //方式三：调用Class的静态方法：forName(String classPath) Class clazz3 = Class.forName(\"com.atguigu.java.Person\"); // clazz3 = Class.forName(\"java.lang.String\"); System.out.println(clazz3); //方式四：使用类的加载器：ClassLoader (了解) ClassLoader classLoader = ReflectionTest.class.getClassLoader(); Class clazz4 = classLoader.loadClass(\"com.atguigu.java.Person\"); System.out.println(clazz4); } //Class实例可以是哪些结构的说明： @Test public void test4(){ Class c1 = Object.class; Class c2 = Comparable.class; Class c3 = String[].class; Class c4 = int[][].class; Class c5 = ElementType.class; Class c6 = Override.class; Class c7 = int.class; Class c8 = void.class; Class c9 = Class.class; int[] a = new int[10]; int[] b = new int[100]; Class c10 = a.getClass(); Class c11 = b.getClass(); // 只要数组的元素类型与维度一样，就是同一个Class System.out.println(c10 == c11); } # 类的加载与 ClassLoader 的理解 类的加载过程 什么 时候会发生类初始化 ？ 类的主动引用（一定会发生类的初始化） ①当虚拟机启动，先初始化 main 方法所在的类 ②new 一个类的对象 ③调用类的静态成员（除了 final 常量）和静态方法 ④使用 java.lang.reflect 包的方法对类进行反射调用 ⑤当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类 类的被动引用（ 不会发生类的初始化） ①当访问一个静态域时，只有真正声明这个域的类才会被初始化 ②当通过子类引用父类的静态变量，不会导致子类初始化 ③通过数组定义类引用，不会触发此类的初始化 ④引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了） 类缓存： 标准的 JavaSE 类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过 JVM 垃圾回收机制可以回收这些 Class 对象 类加载器作用是用来把类 (class) 装载进内存的。 //对于自定义类，使用系统类加载器进行加载 ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); System.out.println(classLoader); //调用系统类加载器的getParent()：获取扩展类加载器 ClassLoader classLoader1 = classLoader.getParent(); System.out.println(classLoader1); //调用扩展类加载器的getParent()：无法获取引导类加载器 //引导类加载器主要负责加载java的核心类库，无法加载自定义类的。 ClassLoader classLoader2 = classLoader1.getParent(); System.out.println(classLoader2); Properties pros = new Properties(); //读取配置文件的方式二：使用ClassLoader //配置文件默认识别为：当前module的src下 ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); InputStream is = classLoader.getResourceAsStream(\"jdbc1.properties\"); pros.load(is); String user = pros.getProperty(\"user\"); String password = pros.getProperty(\"password\"); System.out.println(\"user = \" + user + \",password = \" + password); # 创建运行时类的对象 Class&lt;Person&gt; clazz = Person.class; /* newInstance():调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器。 要想此方法正常的创建运行时类的对象，要求： 1.运行时类必须提供空参的构造器 2.空参的构造器的访问权限得够。通常，设置为public。 在javabean中要求提供一个public的空参构造器。原因： 1.便于通过反射，创建运行时类的对象 2.便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器 */ Person obj = clazz.newInstance(); System.out.println(obj); # 获取运行时类的完整结构 1. 获取属性结构 getFields (): 获取当前运行时类及其父类中声明为 public 访问权限的属性 getDeclaredFields (): 获取当前运行时类中声明的所有属性。（不包含父类中声明的属性） Class clazz = Person.class; Field[] declaredFields = clazz.getDeclaredFields(); for(Field f : declaredFields){ //1.权限修饰符 int modifier = f.getModifiers(); System.out.print(Modifier.toString(modifier) + \"\\t\"); //2.数据类型 Class type = f.getType(); System.out.print(type.getName() + \"\\t\"); //3.变量名 String fName = f.getName(); System.out.print(fName); System.out.println(); } 2. 获取运行时类的方法结构 getMethods (): 获取当前运行时类及其所有父类中声明为 public 权限的方法 getDeclaredMethods (): 获取当前运行时类中声明的所有方法。（不包含父类中声明的方法） Class clazz = Person.class; Method[] declaredMethods = clazz.getDeclaredMethods(); for(Method m : declaredMethods){ //1.获取方法声明的注解 Annotation[] annos = m.getAnnotations(); for(Annotation a : annos){ System.out.println(a); } //2.权限修饰符 System.out.print(Modifier.toString(m.getModifiers()) + \"\\t\"); //3.返回值类型 System.out.print(m.getReturnType().getName() + \"\\t\"); //4.方法名 System.out.print(m.getName()); System.out.print(\"(\"); //5.形参列表 Class[] parameterTypes = m.getParameterTypes(); if(!(parameterTypes == null &amp;&amp; parameterTypes.length == 0)){ for(int i = 0;i &lt; parameterTypes.length;i++){ if(i == parameterTypes.length - 1){ System.out.print(parameterTypes[i].getName() + \" args_\" + i); break; } System.out.print(parameterTypes[i].getName() + \" args_\" + i + \",\"); } } System.out.print(\")\"); //6.抛出的异常 Class[] exceptionTypes = m.getExceptionTypes(); if(exceptionTypes.length &gt; 0){ System.out.print(\"throws \"); for(int i = 0;i &lt; exceptionTypes.length;i++){ if(i == exceptionTypes.length - 1){ System.out.print(exceptionTypes[i].getName()); break; } System.out.print(exceptionTypes[i].getName() + \",\"); } } System.out.println(); } 3. 获取构造器结构 getConstructors (): 获取当前运行时类中声明为 public 的构造器 getDeclaredConstructors (): 获取当前运行时类中声明的所有的构造器 //获取运行时类的父类 Class clazz = Person.class; Class superclass = clazz.getSuperclass(); //获取运行时类的带泛型的父类 Class clazz = Person.class; Type genericSuperclass = clazz.getGenericSuperclass(); //获取运行时类的带泛型的父类的泛型 Class clazz = Person.class; Type genericSuperclass = clazz.getGenericSuperclass(); ParameterizedType paramType = (ParameterizedType) genericSuperclass; //获取泛型类型 Type[] actualTypeArguments = paramType.getActualTypeArguments(); // System.out.println(actualTypeArguments[0].getTypeName()); System.out.println(((Class)actualTypeArguments[0]).getName()); //获取运行时类实现的接口 Class clazz = Person.class; Class[] interfaces = clazz.getInterfaces(); for(Class c : interfaces){ System.out.println(c); } System.out.println(); //获取运行时类的父类实现的接口 Class[] interfaces1 = clazz.getSuperclass().getInterfaces(); for(Class c : interfaces1){ System.out.println(c); } // 获取运行时类所在的包 Class clazz = Person.class; Package pack = clazz.getPackage(); //获取运行时类声明的注解 Class clazz = Person.class; Annotation[] annotations = clazz.getAnnotations(); for(Annotation annos : annotations){ System.out.println(annos); } # 调用运行时类的指定结构 setAccessible 启动和禁用访问安全检查的开关 参数值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查 ①提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为 true。 ② 使得原本无法访问的私有成员也可以访问 // 如何操作运行时类中的指定的属性 @Test public void testField1() throws Exception { Class clazz = Person.class; //创建运行时类的对象 Person p = (Person) clazz.newInstance(); //1. getDeclaredField(String fieldName):获取运行时类中指定变量名的属性 Field name = clazz.getDeclaredField(\"name\"); //2.保证当前属性是可访问的 name.setAccessible(true); //3.获取、设置指定对象的此属性值 name.set(p,\"Tom\"); System.out.println(name.get(p)); } //如何操作运行时类中的指定的方法 @Test public void testMethod() throws Exception { Class clazz = Person.class; //创建运行时类的对象 Person p = (Person) clazz.newInstance(); /* 1.获取指定的某个方法 getDeclaredMethod():参数1 ：指明获取的方法的名称 参数2：指明获取的方法的形参列表 */ Method show = clazz.getDeclaredMethod(\"show\", String.class); //2.保证当前方法是可访问的 show.setAccessible(true); /* 3. 调用方法的invoke():参数1：方法的调用者 参数2：给方法形参赋值的实参 invoke()的返回值即为对应类中调用的方法的返回值。 */ Object returnValue = show.invoke(p,\"CHN\"); //String nation = p.show(\"CHN\"); System.out.println(returnValue); System.out.println(\"*************如何调用静态方法*****************\"); // private static void showDesc() Method showDesc = clazz.getDeclaredMethod(\"showDesc\"); showDesc.setAccessible(true); //如果调用的运行时类中的方法没有返回值，则此invoke()返回null // Object returnVal = showDesc.invoke(null); Object returnVal = showDesc.invoke(Person.class); System.out.println(returnVal);//null } //如何调用运行时类中的指定的构造器 @Test public void testConstructor() throws Exception { Class clazz = Person.class; //private Person(String name) /* 1.获取指定的构造器 getDeclaredConstructor():参数：指明构造器的参数列表 */ Constructor constructor = clazz.getDeclaredConstructor(String.class); //2.保证此构造器是可访问的 constructor.setAccessible(true); //3.调用此构造器创建运行时类的对象 Person per = (Person) constructor.newInstance(\"Tom\"); System.out.println(per); } # 动态代理 interface Human{ String getBelief(); void eat(String food); } //被代理类 class SuperMan implements Human{ @Override public String getBelief() { return \"I believe I can fly!\"; } @Override public void eat(String food) { System.out.println(\"我喜欢吃\" + food); } } class HumanUtil{ public void method1(){ System.out.println(\"====================通用方法一====================\"); } public void method2(){ System.out.println(\"====================通用方法二====================\"); } } /* 要想实现动态代理，需要解决的问题？ 问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。 问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。 */ class ProxyFactory{ //调用此方法，返回一个代理类的对象。解决问题一 public static Object getProxyInstance(Object obj){//obj:被代理类的对象 MyInvocationHandler handler = new MyInvocationHandler(); handler.bind(obj); return Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler); } } class MyInvocationHandler implements InvocationHandler{ private Object obj;//需要使用被代理类的对象进行赋值 public void bind(Object obj){ this.obj = obj; } //当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke() //将被代理类要执行的方法a的功能就声明在invoke()中 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { HumanUtil util = new HumanUtil(); util.method1(); //method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法 //obj:被代理类的对象 Object returnValue = method.invoke(obj,args); util.method2(); //上述方法的返回值就作为当前类中的invoke()的返回值。 return returnValue; } } public class ProxyTest { public static void main(String[] args) { SuperMan superMan = new SuperMan(); //proxyInstance:代理类的对象 Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan); //当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法 String belief = proxyInstance.getBelief(); System.out.println(belief); proxyInstance.eat(\"四川麻辣烫\"); System.out.println(\"*****************************\"); NikeClothFactory nikeClothFactory = new NikeClothFactory(); ClothFactory proxyClothFactory = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory); proxyClothFactory.produceCloth(); } }","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"14-网络编程","slug":"14-网络编程","date":"2021-03-22T04:56:44.000Z","updated":"2021-03-22T09:17:27.523Z","comments":true,"path":"2021/03/22/14-wang-luo-bian-cheng/","link":"","permalink":"http://fsh010816.github.io/2021/03/22/14-wang-luo-bian-cheng/","excerpt":"","text":"# 网络编程 # 网络通信要素 一、网络编程中有两个主要的问题： 1. 如何准确地定位网络上一台或多台主机；定位主机上的特定的应用 2. 找到主机后如何可靠高效地进行数据传输 二、网络编程中的两个要素： 1. 对应问题一：IP 和端口号 2. 对应问题二：提供网络通信协议：TCP/IP 参考模型（应用层、传输层、网络层、物理 + 数据链路层） 三、通信要素一：IP 和端口号 1.IP: 唯一的标识 Internet 上的计算机（通信实体） 2. 在 Java 中使用 InetAddress 类代表 IP 3.IP 分类：IPv4 和 IPv6 ; 万维网 和 局域网 4. 域名: www.baidu.com www.mi.com www.sina.com www.jd.com www.vip.com 5. 本地回路地址：127.0.0.1 对应着：localhost 6. 如何实例化 InetAddress: 两个方法：getByName (String host) 、 getLocalHost () 两个常用方法：getHostName () /getHostAddress () 7. 端口号：正在计算机上运行的进程。 要求：不同的进程有不同的端口号 范围：被规定为一个 16 位的整数 0~65535。 8. 端口号与 IP 地址的组合得出一个网络套接字：Socket # 实现 TCP 的网络编程 //客户端 @Test public void client() { Socket socket = null; OutputStream os = null; try { //1.创建Socket对象，指明服务器端的ip和端口号 InetAddress inet = InetAddress.getByName(\"192.168.14.100\"); socket = new Socket(inet,8899); //2.获取一个输出流，用于输出数据 os = socket.getOutputStream(); //3.写出数据的操作 os.write(\"你好，我是客户端mm\".getBytes()); } catch (IOException e) { e.printStackTrace(); } finally { //4.资源的关闭 if(os != null){ try { os.close(); } catch (IOException e) { e.printStackTrace(); } } if(socket != null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } //服务端 @Test public void server() { ServerSocket ss = null; Socket socket = null; InputStream is = null; ByteArrayOutputStream baos = null; try { //1.创建服务器端的ServerSocket，指明自己的端口号 ss = new ServerSocket(8899); //2.调用accept()表示接收来自于客户端的socket socket = ss.accept(); //3.获取输入流 is = socket.getInputStream(); //不建议这样写，可能会有乱码 // byte[] buffer = new byte[1024]; // int len; // while((len = is.read(buffer)) != -1){ // String str = new String(buffer,0,len); // System.out.print(str); // } //4.读取输入流中的数据 baos = new ByteArrayOutputStream(); byte[] buffer = new byte[5]; int len; while((len = is.read(buffer)) != -1){ baos.write(buffer,0,len); } System.out.println(baos.toString()); System.out.println(\"收到了来自于：\" + socket.getInetAddress().getHostAddress() + \"的数据\"); } catch (IOException e) { e.printStackTrace(); } finally { if(baos != null){ //5.关闭资源 try { baos.close(); } catch (IOException e) { e.printStackTrace(); } } if(is != null){ try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if(socket != null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } if(ss != null){ try { ss.close(); } catch (IOException e) { e.printStackTrace(); } } } } /* 实现TCP的网络编程 例题3：从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。 并关闭相应的连接。 */ @Test public void client() throws IOException { //1. Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"),9090); //2. OutputStream os = socket.getOutputStream(); //3. FileInputStream fis = new FileInputStream(new File(\"beauty.jpg\")); //4. byte[] buffer = new byte[1024]; int len; while((len = fis.read(buffer)) != -1){ os.write(buffer,0,len); } //关闭数据的输出 socket.shutdownOutput(); //5.接收来自于服务器端的数据，并显示到控制台上 InputStream is = socket.getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] bufferr = new byte[20]; int len1; while((len1 = is.read(buffer)) != -1){ baos.write(buffer,0,len1); } System.out.println(baos.toString()); //6. fis.close(); os.close(); socket.close(); baos.close(); } /* 这里涉及到的异常，应该使用try-catch-finally处理 */ @Test public void server() throws IOException { //1. ServerSocket ss = new ServerSocket(9090); //2. Socket socket = ss.accept(); //3. InputStream is = socket.getInputStream(); //4. FileOutputStream fos = new FileOutputStream(new File(\"beauty2.jpg\")); //5. byte[] buffer = new byte[1024]; int len; while((len = is.read(buffer)) != -1){ fos.write(buffer,0,len); } System.out.println(\"图片传输完成\"); //6.服务器端给予客户端反馈 OutputStream os = socket.getOutputStream(); os.write(\"你好，美女，照片我已收到，非常漂亮！\".getBytes()); //7. fos.close(); is.close(); socket.close(); ss.close(); os.close(); } # UDP 协议的网络编程 //发送端 @Test public void sender() throws IOException { DatagramSocket socket = new DatagramSocket(); String str = \"我是UDP方式发送的导弹\"; byte[] data = str.getBytes(); InetAddress inet = InetAddress.getLocalHost(); DatagramPacket packet = new DatagramPacket(data,0,data.length,inet,9090); socket.send(packet); socket.close(); } //接收端 @Test public void receiver() throws IOException { DatagramSocket socket = new DatagramSocket(9090); byte[] buffer = new byte[100]; DatagramPacket packet = new DatagramPacket(buffer,0,buffer.length); socket.receive(packet); System.out.println(new String(packet.getData(),0,packet.getLength())); socket.close(); } # URL 网络编程 1.URL: 统一资源定位符，对应着互联网的某一资源地址 2. 格式： http://localhost:8080/examples/beauty.jpg?username=Tom 协议 主机名 端口号 资源地址 参数列表 方法： public String getProtocol ( ) 获取该 URL 的协议名 public String getHost ( ) 获取该 URL 的主机名 public String getPort ( ) 获取该 URL 的端口号 public String getPath ( ) 获取该 URL 的文件路径 public String getFile ( ) 获取该 URL 的文件名 public String getQuery ( ) 获取该 URL 的查询名 public static void main(String[] args) { HttpURLConnection urlConnection = null; InputStream is = null; FileOutputStream fos = null; try { URL url = new URL(\"http://localhost:8080/examples/beauty.jpg\"); urlConnection = (HttpURLConnection) url.openConnection(); urlConnection.connect(); is = urlConnection.getInputStream(); fos = new FileOutputStream(\"day10\\\\beauty3.jpg\"); byte[] buffer = new byte[1024]; int len; while((len = is.read(buffer)) != -1){ fos.write(buffer,0,len); } System.out.println(\"下载完成\"); } catch (IOException e) { e.printStackTrace(); } finally { //关闭资源 if(is != null){ try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if(fos != null){ try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } if(urlConnection != null){ urlConnection.disconnect(); } } }","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"13-IO流","slug":"13-IO流","date":"2021-03-22T04:56:21.000Z","updated":"2021-03-22T15:28:42.106Z","comments":true,"path":"2021/03/22/13-io-liu/","link":"","permalink":"http://fsh010816.github.io/2021/03/22/13-io-liu/","excerpt":"","text":"# IO 流 # File 类的使用 1.File 类的一个对象，代表一个文件或一个文件目录 (俗称：文件夹) 2.File 类声明在 java.io 包下 3.File 类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用 IO 流来完成。 4. 后续 File 类的对象常会作为参数传递到流的构造器中，指明读取或写入的 \"终点\". 5. 想要在 Java 程序中表示一个真实存在的文件或目录，那么必须有一个 File 对象，但是 Java 程序中的一个 File 对象，可能没有一个真实存在的文件或目录。 # 如何创建 File 类的实例 File(String filePath) File(String parentPath,String childPath) File(File parentFile,String childPath) 2. 相对路径：相较于某个路径下，指明的路径。 绝对路径：包含盘符在内的文件或文件目录的路径 /* 路径分隔符 windows:\\\\ unix:/ */ # 方法 public String getAbsolutePath ()：获取绝对路径 public String getPath () ：获取路径 public String getName () ：获取名称 public String getParent ()：获取上层文件目录路径。若无，返回 null public long length () ：获取文件长度（即：字节数）。不能获取目录的长度。 public long lastModified () ：获取最后一次的修改时间，毫秒值 如下的两个方法适用于文件目录： public String [] list () ：获取指定目录下的所有文件或者文件目录的名称数组 public File [] listFiles () ：获取指定目录下的所有文件或者文件目录的 File 数组 public boolean renameTo (File dest): 把文件重命名为指定的文件路径 比如：file1.renameTo (file2) 为例： 要想保证返回 true, 需要 file1 在硬盘中是存在的，且 file2 不能在硬盘中存在。 public boolean isDirectory ()：判断是否是文件目录 public boolean isFile () ：判断是否是文件 public boolean exists () ：判断是否存在 public boolean canRead () ：判断是否可读 public boolean canWrite () ：判断是否可写 public boolean isHidden () ：判断是否隐藏 创建硬盘中对应的文件或文件目录 public boolean createNewFile () ：创建文件。若文件存在，则不创建，返回 false public boolean mkdir () ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。 public boolean mkdirs () ：创建文件目录。如果此文件目录存在，就不创建了。如果上层文件目录不存在，一并创建 注意事项：如果你创建文件或者 文件 目录没有 写 盘符路径 ， 那么 ， 默认在项目路径下 删除磁盘中的文件或文件目录 public boolean delete ()：删除文件或者文件夹 删除注意事项：Java 中的删除不走回收站。 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录 # 流 I/O 技术是非常实用的技术，用于处理设备之间的数据传输。如读 / 写文件，网络通讯等。 输入 input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。 输出 output：将程序（内存）数据输出到磁盘、光盘等存储设备中。 程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件 IO 资源 # 流的分类 1. 操作数据单位：字节流、字符流 2. 数据的流向：输入流、输出流 3. 流的角色：节点流、处理流 处理流：不直接连接到数据源或目的地，而是 “连接” 在已存在的流（节点流或处理流）之上 # 流的体系结构 异常的处理：为了保证流资源一定可以执行关闭操作。需要使用 try-catch-finally 处理 # FileReader、FileWriter 读入操作： ①读入的文件一定要存在，否则就会报 FileNotFoundException。 ②read () 的理解：返回读入的一个字符。如果达到文件末尾，返回 - 1 ③read (char [] cbuf): 返回每次读入 cbuf 数组中的字符的个数。如果达到文件末尾，返回 - 1 从内存中写出数据到硬盘的文件里: ①输出操作，对应的 File 可以不存在的。并不会报异常 ② File 对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。 File 对应的硬盘中的文件如果存在： 如果流使用的构造器是：FileWriter (file,false) / FileWriter (file): 对原有文件的覆盖 如果流使用的构造器是：FileWriter (file,true): 不会对原有文件覆盖，而是在原有文件基础上追加内容 @Test public void testFileReaderFileWriter(){ //1.创建File类的对象，指明读入和写出的文件 FileReader fr = null; FileWriter fw = null; try { File srcFile = new File(\"hello.txt\"); File destFile = new File(\"hello2.txt\"); //2.创建输入流和输出流的对象 fr = new FileReader(srcFile); fw = new FileWriter(destFile); //3.数据的读入和写出操作 char[] cbuf = new char[5]; int len;//记录每次读入到cbuf数组中的字符的个数 while ((len = fr.read(cbuf))!=-1){ //每次写出len个字符 fw.write(cbuf,0,len); } } catch (IOException e) { e.printStackTrace(); } finally { //4.关闭流资源 if (fw!=null){ try { fw.close(); } catch (IOException e) { e.printStackTrace(); } } if (fr != null){ try { fr.close(); } catch (IOException e) { e.printStackTrace(); } } } } # InputStream、OutputStream 1. 对于文本文件 (.txt,.java,.c,.cpp)，使用字符流处理 2. 对于非文本文件 (.jpg,.mp3,.mp4,.avi,.doc,.ppt,…)，使用字节流处理 使用字节流 FileInputStream 处理文本文件，可能出现乱码。复制操作正常 # 缓冲流的使用 1. 作用：提供流的读取、写入的速度 2. 提高读写速度的原因：内部提供了一个缓冲区 3. 处理流，就是 “套接” 在已有的流的基础上。 4. 关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流 5.flush () 方法的使用：手动将 buffer 中内容写入文件 6. 如果是带缓冲区的流对象的 close () 方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭后不能再写出 /* 使用BufferedReader和BufferedWriter实现文本文件的复制 */ @Test public void testBufferedReaderBufferedWriter(){ BufferedReader br = null; BufferedWriter bw = null; try { //创建文件和相应的流 br = new BufferedReader(new FileReader(new File(\"dbcp.txt\"))); bw = new BufferedWriter(new FileWriter(new File(\"dbcp1.txt\"))); //读写操作 //方式一：使用char[]数组 // char[] cbuf = new char[1024]; // int len; // while((len = br.read(cbuf)) != -1){ // bw.write(cbuf,0,len); // // bw.flush(); // } //方式二：使用String String data; while((data = br.readLine()) != null){ //方法一： // bw.write(data + \"\\n\");//data中不包含换行符 //方法二： bw.write(data);//data中不包含换行符 bw.newLine();//提供换行的操作 } } catch (IOException e) { e.printStackTrace(); } finally { //关闭资源 if(bw != null){ try { bw.close(); } catch (IOException e) { e.printStackTrace(); } } if(br != null){ try { br.close(); } catch (IOException e) { e.printStackTrace(); } } } } # 转换流的使用 InputStreamReader：将一个字节的输入流转换为字符的输入流 OutputStreamWriter：将一个字符的输出流转换为字节的输出流 作用：提供字节流与字符流之间的转换。很多时候我们使用转换流来处理文件乱码问题。实现编码和 解码的功能 解码：字节、字节数组 —&gt; 字符数组、字符串 编码：字符数组、字符串 —&gt; 字节、字节数组 FileInputStream fis = new FileInputStream(\"dbcp.txt\"); // InputStreamReader isr = new InputStreamReader(fis);//使用系统默认的字符集 //参数2指明了字符集，具体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集 InputStreamReader isr = new InputStreamReader(fis,\"UTF-8\");//使用系统默认的字符集 # 其他流的使用 # 标准的输入、输出流 System.in: 标准的输入流，默认从键盘输入 System.out: 标准的输出流，默认从控制台输出 System.in 的类型是 InputStream，System.out 的类型是 PrintStream System 类的 setIn (InputStream is) /setOut (PrintStream ps) 方式重新指定输入和输出的流。 /* 练习： 从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作， 直至当输入“e”或者“exit”时，退出程序。 方法一：使用Scanner实现，调用next()返回一个字符串 方法二：使用System.in实现。System.in ---&gt; 转换流 ---&gt; BufferedReader的readLine() */ public static void main(String[] args) { BufferedReader br = null; try { InputStreamReader isr = new InputStreamReader(System.in); br = new BufferedReader(isr); while (true) { System.out.println(\"请输入字符串：\"); String data = br.readLine(); if (\"e\".equalsIgnoreCase(data) || \"exit\".equalsIgnoreCase(data)) { System.out.println(\"程序结束\"); break; } String upperCase = data.toUpperCase(); System.out.println(upperCase); } } catch (IOException e) { e.printStackTrace(); } finally { if (br != null) { try { br.close(); } catch (IOException e) { e.printStackTrace(); } } } } # 打印流 1.PrintStream 和 PrintWriter 提供了一系列重载的 print () 和 println () 2.PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。 3. 实现将基本数据类型的数据格式转化为字符串输出 @Test public void test2() { PrintStream ps = null; try { FileOutputStream fos = new FileOutputStream(new File(\"D:\\\\IO\\\\text.txt\")); // 创建打印输出流,设置为自动刷新模式(写入换行符或字节 '\\n' 时都会刷新输出缓冲区) ps = new PrintStream(fos, true); if (ps != null) {// 把标准输出流(控制台输出)改成文件 System.setOut(ps); } for (int i = 0; i &lt;= 255; i++) { // 输出ASCII字符 System.out.print((char) i); if (i % 50 == 0) { // 每50个数据一行 System.out.println(); // 换行 } } } catch (FileNotFoundException e) { e.printStackTrace(); } finally { if (ps != null) { ps.close(); } } } # 数据流 DataInputStream 和 DataOutputStream 作用：用于读取或写出基本数据类型的变量或字符串 //练习：将内存中的字符串、基本数据类型的变量写出到文件中。 @Test public void test3() throws IOException { //1. DataOutputStream dos = new DataOutputStream(new FileOutputStream(\"data.txt\")); //2. dos.writeUTF(\"刘建辰\"); dos.flush();//刷新操作，将内存中的数据写入文件 dos.writeInt(23); dos.flush(); dos.writeBoolean(true); dos.flush(); //3. dos.close(); } /* 将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。 注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！ */ @Test public void test4() throws IOException { //1. DataInputStream dis = new DataInputStream(new FileInputStream(\"data.txt\")); //2. String name = dis.readUTF(); int age = dis.readInt(); boolean isMale = dis.readBoolean(); System.out.println(\"name = \" + name); System.out.println(\"age = \" + age); System.out.println(\"isMale = \" + isMale); //3. dis.close(); } # 对象流的使用 ObjectInputStream 和 ObjectOutputStream 1. 作用：用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把 Java 中的对象写入到数据源中，也能把对象从数据源中还原回来。 2. 要想一个 java 对象是可序列化的，需要满足相应的要求。 Person 需要满足如下的要求，方可序列化 ①. 需要实现接口：Serializable ②. 当前类提供一个全局常量：serialVersionUID ③. 除了当前 Person 类需要实现 Serializable 接口之外，还必须保证其内部所有属性也必须是可序列化的。（默认情况下，基本数据类型可序列化） ④ObjectOutputStream 和 ObjectInputStream 不能序列化 static 和 transient 修饰的成员变量 3. 序列化机制： 对象序列化机制允许把内存中的 Java 对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的 Java 对象。 /* 序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去 使用ObjectOutputStream实现 */ @Test public void testObjectOutputStream(){ ObjectOutputStream oos = null; try { //1. oos = new ObjectOutputStream(new FileOutputStream(\"object.dat\")); //2.调用ObjectOutputStream对象的writeObject(对象)方法输出可序列化对象 oos.writeObject(new String(\"我爱北京天安门\")); oos.flush();//刷新操作 oos.writeObject(new Person(\"王铭\",23)); oos.flush(); oos.writeObject(new Person(\"张学良\",23,1001,new Account(5000))); oos.flush(); } catch (IOException e) { e.printStackTrace(); } finally { if(oos != null){ //3. try { oos.close(); } catch (IOException e) { e.printStackTrace(); } } } } /* 反序列化：将磁盘文件中的对象还原为内存中的一个java对象 使用ObjectInputStream来实现 */ @Test public void testObjectInputStream(){ ObjectInputStream ois = null; try { ois = new ObjectInputStream(new FileInputStream(\"object.dat\")); Object obj = ois.readObject(); String str = (String) obj; Person p = (Person) ois.readObject(); Person p1 = (Person) ois.readObject(); System.out.println(str); System.out.println(p); System.out.println(p1); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } finally { if(ois != null){ try { ois.close(); } catch (IOException e) { e.printStackTrace(); } } } } # RandomAccessFile 的使用 1.RandomAccessFile 直接继承于 java.lang.Object 类，实现了 DataInput 和 DataOutput 接口 2.RandomAccessFile 既可以作为一个输入流，又可以作为一个输出流 3. 如果 RandomAccessFile 作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。 如果写出到的文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖） 4. 可以通过相关的操作，实现 RandomAccessFile “插入” 数据的效果 /* 使用RandomAccessFile实现数据的插入效果 */ @Test public void test3() throws IOException { RandomAccessFile raf1 = new RandomAccessFile(\"hello.txt\",\"rw\"); raf1.seek(3);//将指针调到角标为3的位置 //保存指针3后面的所有数据到StringBuilder中 StringBuilder builder = new StringBuilder((int) new File(\"hello.txt\").length()); byte[] buffer = new byte[20]; int len; while((len = raf1.read(buffer)) != -1){ builder.append(new String(buffer,0,len)) ; } //调回指针，写入“xyz” raf1.seek(3); raf1.write(\"xyz\".getBytes()); //将StringBuilder中的数据写入到文件中 raf1.write(builder.toString().getBytes()); raf1.close(); } # Path、Paths、Files","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"12-泛型","slug":"12-泛型","date":"2021-03-19T12:31:19.000Z","updated":"2021-03-19T13:11:29.638Z","comments":true,"path":"2021/03/19/12-fan-xing/","link":"","permalink":"http://fsh010816.github.io/2021/03/19/12-fan-xing/","excerpt":"","text":"# 泛型 # 在集合中使用泛型 ① 集合接口或集合类在 jdk5.0 时都修改为带泛型的结构。 ② 在实例化集合类时，可以指明具体的泛型类型 ③ 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。 比如：add (E e) —&gt; 实例化以后：add (Integer e) ④ 注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换 ⑤ 如果实例化时，没有指明泛型的类型。默认类型为 java.lang.Object 类型。 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();//类型推断 # 自定义泛型结构 泛型类、泛型接口；泛型方法 关于自定义泛型类、泛型接口： ①如果定义了泛型类，实例化没有指明类的泛型，则认为此泛型类型为 Object 类型，但不等价于 Object 要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型。建议：实例化时指明类的泛型 ②泛型不同的引用不能相互赋值。 ③异常类不能声明为泛型类 ④静态方法中不能使用类的泛型。 ⑤泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。换句话说，泛型方法所属的类是不是泛型类都没有关系。泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。 [访问权限] &lt; 泛型 &gt; 返回类型 方法名 ([泛型标识 参数名称]) 抛出的异常 ⑥泛型类的构造器在声明时不能加 &lt;&gt; ⑦不能使用 new E []。但是可以：E [] elements = (E []) new Object [capacity]; 参考：ArrayList 源码中声明：Object [] elementData，而非泛型参数类型数组。 # 泛型在继承方面的体现 //虽然类A是类B的父类，但是G&lt;A&gt; 和G&lt;B&gt;二者不具备子父类关系，二者是并列关系。补充：类A是类B的父类，A&lt;G&gt; 是 B&lt;G&gt; 的父类 子类不保留父类的泛型：按需实现 没有类型 擦除 具体类型 子类保留父类的泛型：泛型子类 全部保留 部分保留 # 通配符的使用 /* 通配符：? 类A是类B的父类，G&lt;A&gt;和G&lt;B&gt;是没有关系的，二者共同的父类是：G&lt;?&gt; 添加(写入)：对于List&lt;?&gt;就不能向其内部添加数据。除了添加null之外。 获取(读取)：允许读取数据，读取的数据类型为Object。 */ /* 有限制条件的通配符的使用。 ? extends A: G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类 ? super A: G&lt;? super A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类 &lt;? extends Comparable&gt; 只允许泛型为实现Comparable接口的实现类的引用调用 */","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"11-Java集合","slug":"11-Java集合","date":"2021-02-01T08:09:08.000Z","updated":"2022-03-01T10:13:49.331Z","comments":true,"path":"2021/02/01/11-java-ji-he/","link":"","permalink":"http://fsh010816.github.io/2021/02/01/11-java-ji-he/","excerpt":"","text":"# Java 集合 # 集合框架的概述 # 集合概述 集合、数组都是对多个数据进行存储操作的结构，简称 Java 容器。 说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中） 在 Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成 Object 类型处理；从 JDK 5.0 增加了 泛型以后，Java 集合可以记住容器中对象的数据类型 # 数组优缺点 ①数组在存储多个数据方面的特点： 1. 一旦初始化以后，其长度就确定了。 2. 数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。 比如：String [] arr;int [] arr1;Object [] arr2; ②数组在存储多个数据方面的缺点： 1. 一旦初始化以后，其长度就不可修改。 2. 数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。 3. 获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用 4. 数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。 # 集合框架 /* * |----Collection接口：单列集合，用来存储一个一个的对象 * |----List接口：存储有序的、可重复的数据。 --&gt;“动态”数组 * |----ArrayList、LinkedList、Vector * * |----Set接口：存储无序的、不可重复的数据 --&gt;高中讲的“集合” * |----HashSet、LinkedHashSet、TreeSet * * |----Map接口：双列集合，用来存储一对(key - value)一对的数据 --&gt;高中函数：y = f(x) * |----HashMap、LinkedHashMap、TreeMap、Hashtable、Properties */ # Collection 接口中的方法的使用 结论：向 Collection 接口的实现类的对象中添加数据 obj 时，要求 obj 所在类要重写 equals (). add (Object e): 将元素 e 添加到集合 coll 中 size (): 获取添加的元素的个数 addAll (Collection coll1): 将 coll1 集合中的元素添加到当前的集合中 clear (): 清空集合元素 isEmpty (): 判断当前集合是否为空 contains (Object obj): 判断当前集合中是否包含 obj。我们在判断时会调用 obj 对象所在类的 equals ()。 containsAll (Collection coll1): 判断形参 coll1 中的所有元素是否都存在于当前集合中。 remove (Object obj): 从当前集合中移除 obj 元素。只会删除找到的第一个元素 removeAll (Collection coll1): 差集：从当前集合中移除 coll1 中所有的元素。 retainAll (Collection coll1): 交集：获取当前集合和 coll1 集合的交集，并返回给当前集合 equals (Object obj): 要想返回 true，需要当前集合和形参集合的元素都相同。 hashCode (): 返回当前对象的哈希值 集合 —&gt; 数组：toArray () 数组 —&gt; 集合：调用 Arrays 类的静态方法 asList ()。 Arrays.asList (…) 返回值是一个固定长度的 List 集合 iterator (): 返回 Iterator 接口的实例，用于遍历集合元素。 集合元素的遍历操作，使用迭代器 Iterator 接口 ①. 内部的方法：hasNext () 和 next ()：①指针下移 ②将下移以后集合位置上的元素返回 ②. 集合对象每次调用 iterator () 方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。 Iterator 仅用于遍历集合 ③. 内部定义了 remove (), 可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用 remove ()。如果还未调用 next () 或在上一次调用 next 方法之后已经调用了 remove 方法，再调用 remove 都会报 IllegalStateException。 jdk 5.0 新增了 foreach 循环，用于遍历集合、数组： for (集合元素的类型 局部变量：集合对象)。内部仍然调用了迭代器。 for (数组元素的类型 局部变量：数组对象) # List 接口框架 /**1. List接口框架 * * |----Collection接口：单列集合，用来存储一个一个的对象 * |----List接口：存储有序的、可重复的数据。 --&gt;“动态”数组,替换原有的数组 * |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储 * |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储 * |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储 * * * 2. ArrayList的源码分析： * 2.1 jdk 7情况下 * ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData * list.add(123);//elementData[0] = new Integer(123); * ... * list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。 * 默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。 * * 结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity) * * 2.2 jdk 8中ArrayList的变化： * ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.并没有创建长度为10的数组 * * list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0] * ... * 后续的添加和扩容操作与jdk 7 无异。 * 2.3 小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象 * 的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。 * * 3. LinkedList的源码分析： 双向链表，内部没有声明数组 * LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null * list.add(123);//将123封装到Node中，创建了Node对象。 * * 其中，Node定义为：体现了LinkedList的双向链表的说法 * private static class Node&lt;E&gt; { E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; } } * * 4. Vector的源码分析：jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。 * 在扩容方面，默认扩容为原来的数组长度的2倍。 * * 面试题：ArrayList、LinkedList、Vector三者的异同？ * 同：三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据 * 不同：见上 */ # List 接口中的常用方法 void add (int index, Object ele): 在 index 位置插入 ele 元素 boolean addAll (int index, Collection eles): 从 index 位置开始将 eles 中的所有元素添加进来 Object get (int index): 获取指定 index 位置的元素 int indexOf (Object obj): 返回 obj 在集合中首次出现的位置。如果不存在，返回 - 1. int lastIndexOf (Object obj): 返回 obj 在当前集合中末次出现的位置。如果不存在，返回 - 1. Object remove (int index): 移除指定 index 位置的元素，并返回此元素 Object set (int index, Object ele): 设置指定 index 位置的元素为 ele List subList (int fromIndex, int toIndex): 返回从 fromIndex 到 toIndex 位置的左闭右开区间的子集合 LinkedList 新增方法: void addFirst(Object obj) void addLast(Object obj) Object getFirst() Object getLast() Object removeFirst() Object removeLast() # Set 接口的框架 /** * 1. Set接口的框架： * * |----Collection接口：单列集合，用来存储一个一个的对象 * |----Set接口：存储无序的、不可重复的数据 --&gt;高中讲的“集合” * |----HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值 * |----LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历 * 对于频繁的遍历操作，LinkedHashSet效率高于HashSet. * |----TreeSet：可以按照添加对象的指定属性，进行排序。 */ 1.Set 接口中没有额外定义新的方法，使用的都是 Collection 中声明过的方法。 HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode () 方法比较相等，并且两个对象的 equals () 方法返回值也相等。 2. 要求：向 Set (主要指：HashSet、LinkedHashSet) 中添加的数据，其所在的类一定要重写 hashCode () 和 equals () 要求：重写的 hashCode () 和 equals () 尽可能保持一致性：相等的对象必须具有相等的散列码 重写两个方法的小技巧：对象中用作 equals () 方法比较的 Field，都应该用来计算 hashCode 值。 /* 一、Set：存储无序的、不可重复的数据 以HashSet为例说明： 1. 无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。 2. 不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。 二、添加元素的过程：以HashSet为例： 我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值， 此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断 数组此位置上是否已经有元素： 如果此位置上没有其他元素，则元素a添加成功。 ---&gt;情况1 如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值： 如果hash值不相同，则元素a添加成功。---&gt;情况2 如果hash值相同，进而需要调用元素a所在类的equals()方法： equals()返回true,元素a添加失败 equals()返回false,则元素a添加成功。---&gt;情况2 对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。 jdk 7 :元素a放到数组中，指向原来的元素。 jdk 8 :原来的元素在数组中，指向元素a 总结：七上八下 HashSet底层：数组+链表的结构。(jdk7) */ LinkedHashSet 的使用 LinkedHashSet 作为 HashSet 的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。这使得元素看起来是以插入顺序保存的。 优点：对于频繁的遍历操作，LinkedHashSet 效率高于 HashSet /* 1.向TreeSet中添加的数据，要求是相同类的对象。 2.两种排序方式：自然排序（实现Comparable接口） TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列 和 定制排序（Comparator） 3.自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals(). 4.定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals(). */ TreeSet 底层使用红黑树结构存储数据 向 TreeSet 中添加元素时，只有第一个元素无须比较 compareTo () 方法，后面添加的所有元素都会调用 compareTo () 方法进行比较。 因为只有相同类的两个实例才会比较大小，所以向 TreeSet 中添加的应该是同一个类的对象。 # Map /** * 一、Map的实现类的结构： * |----Map:双列数据，存储key-value对的数据 ---类似于高中的函数：y = f(x) * |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value * |----LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。 * 原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。 * 对于频繁的遍历操作，此类执行效率高于HashMap。 * |----TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序 * 底层使用红黑树 * |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value * |----Properties:常用来处理配置文件。key和value都是String类型 * * * HashMap的底层：数组+链表 （jdk7及之前） * 数组+链表+红黑树 （jdk 8） * * * 面试题： * 1. HashMap的底层实现原理？ * 2. HashMap 和 Hashtable的异同？ * 3. CurrentHashMap 与 Hashtable的异同？（暂时不讲） * * 二、Map结构的理解： * Map中的key:无序的、不可重复的，使用Set存储所有的key ---&gt; key所在的类要重写equals()和hashCode() （以HashMap为例） * Map中的value:无序的、可重复的，使用Collection存储所有的value ---&gt;value所在的类要重写equals() * 一个键值对：key-value构成了一个Entry对象。 * Map中的entry:无序的、不可重复的，使用Set存储所有的entry * * 三、HashMap的底层实现原理？以jdk7为例说明： * HashMap map = new HashMap(): * 在实例化以后，底层创建了长度是16的一维数组Entry[] table。 * ...可能已经执行过多次put... * map.put(key1,value1): * 首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。 * 如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1 * 如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据 * 的哈希值： * 如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2 * 如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较： * 如果equals()返回false:此时key1-value1添加成功。----情况3 * 如果equals()返回true:使用value1替换value2。 * * 补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。 * * 在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。 * * jdk8 相较于jdk7在底层实现方面的不同： * 1. new HashMap():底层没有创建一个长度为16的数组 * 2. jdk 8底层的数组是：Node[],而非Entry[] * 3. 首次调用put()方法时，底层创建长度为16的数组 * 4. jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。 * 4.1 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素） 4.2 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。 * * DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16 * DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75 * threshold：扩容的临界值，=容量*填充因子：16 * 0.75 =&gt; 12 * TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8 * MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64 * * 四、LinkedHashMap的底层实现原理（了解） * 源码中： * static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; { Entry&lt;K,V&gt; before, after;//能够记录添加的元素的先后顺序 Entry(int hash, K key, V value, Node&lt;K,V&gt; next) { super(hash, key, value, next); } } * * * 五、Map中定义的方法： 添加、删除、修改操作： Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中 void putAll(Map m):将m中的所有key-value对存放到当前map中 Object remove(Object key)：移除指定key的key-value对，并返回value void clear()：清空当前map中的所有数据 元素查询的操作： Object get(Object key)：获取指定key对应的value boolean containsKey(Object key)：是否包含指定的key boolean containsValue(Object value)：是否包含指定的value int size()：返回map中key-value对的个数 boolean isEmpty()：判断当前map是否为空 boolean equals(Object obj)：判断当前map和参数对象obj是否相等 元视图操作的方法： Set keySet()：返回所有key构成的Set集合 Collection values()：返回所有value构成的Collection集合 Set entrySet()：返回所有key-value对构成的Set集合，entrySet集合中的元素都是entry *总结：常用方法： * 添加：put(Object key,Object value) * 删除：remove(Object key) * 修改：put(Object key,Object value) * 查询：get(Object key) * 长度：size() * 遍历：keySet() / values() / entrySet() * * * @author shkstart * @create 2019 上午 11:15 */ LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致 向 TreeMap 中添加 key-value，要求 key 必须是由同一个类创建的对象 因为要按照 key 进行排序：自然排序 、定制排序 Properties: 常用来处理配置文件。key 和 value 都是 String 类型。存取数据时，建议使用 setProperty (String key,String value) 方法和 getProperty (String key) 方法 # Collections Collections: 操作 Collection、Map 的工具类 /* reverse(List)：反转 List 中元素的顺序 shuffle(List)：对 List 集合元素进行随机排序 sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序 sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序 swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换 Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素 Object min(Collection) Object min(Collection，Comparator) int frequency(Collection，Object)：返回指定集合中指定元素的出现次数 void copy(List dest,List src)：将src中的内容复制到dest中 boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值 */ Collections 类中提供了多个 synchronizedXxx () 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"10-枚举类与注解","slug":"10-枚举类与注解","date":"2021-01-31T10:48:35.000Z","updated":"2022-10-30T10:56:16.265Z","comments":true,"path":"2021/01/31/10-mei-ju-lei-yu-zhu-jie/","link":"","permalink":"http://fsh010816.github.io/2021/01/31/10-mei-ju-lei-yu-zhu-jie/","excerpt":"","text":"# 枚举类与注解 # 1. 枚举类 /** * 一、枚举类的使用 * 1.枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类 * 2.当需要定义一组常量时，强烈建议使用枚举类 * 3.如果枚举类中只有一个对象，则可以作为单例模式的实现方式。 * * 二、如何定义枚举类 * 方式一：jdk5.0之前，自定义枚举类 * 方式二：jdk5.0，可以使用enum关键字定义枚举类 * * 三、Enum类中的常用方法： * values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。 * valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。 * toString()：返回当前枚举类对象常量的名称 * * 四、使用enum关键字定义的枚举类实现接口的情况 * 情况一：实现接口，在enum类中实现抽象方法 * 情况二：让枚举类的对象分别实现接口中的抽象方法 * * @author shkstart * @create 2019 上午 10:17 */ public class SeasonTest { public static void main(String[] args) { Season spring = Season.SPRING; System.out.println(spring); } } //自定义枚举类 class Season{ //1.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私有化类的构造器,并给对象属性赋值 private Season(String seasonName,String seasonDesc){ this.seasonName = seasonName; this.seasonDesc = seasonDesc; } //3.提供当前枚举类的多个对象：public static final的 public static final Season SPRING = new Season(\"春天\",\"春暖花开\"); public static final Season SUMMER = new Season(\"夏天\",\"夏日炎炎\"); public static final Season AUTUMN = new Season(\"秋天\",\"秋高气爽\"); public static final Season WINTER = new Season(\"冬天\",\"冰天雪地\"); //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; } //4.其他诉求1：提供toString() @Override public String toString() { return \"Season{\" + \"seasonName='\" + seasonName + '\\'' + \", seasonDesc='\" + seasonDesc + '\\'' + '}'; } } /** * 使用enum关键字定义枚举类 * 说明：定义的枚举类默认继承于java.lang.Enum类，因此不能再继承其他类 枚举类的构造器只能使用 private 权限修饰符 *JDK 1.5 中可以在 switch 表达式中使用Enum定义的枚举类的对象作为表达式, case 子句可 *以直接使用枚举值的名字, 无需添加枚举类作为限定。 * @author shkstart * @create 2019 上午 10:35 */ public class SeasonTest1 { public static void main(String[] args) { Season1 summer = Season1.SUMMER; //toString():返回枚举类对象的名称 System.out.println(summer.toString()); // System.out.println(Season1.class.getSuperclass()); System.out.println(\"****************\"); //values():返回所有的枚举类对象构成的数组 Season1[] values = Season1.values(); for(int i = 0;i &lt; values.length;i++){ System.out.println(values[i]); values[i].show(); } System.out.println(\"****************\"); Thread.State[] values1 = Thread.State.values(); for (int i = 0; i &lt; values1.length; i++) { System.out.println(values1[i]); } //valueOf(String objName):返回枚举类中对象名是objName的对象。 Season1 winter = Season1.valueOf(\"WINTER\"); //如果没有objName的枚举类对象，则抛异常：IllegalArgumentException // Season1 winter = Season1.valueOf(\"WINTER1\"); System.out.println(winter); winter.show(); } } interface Info{ void show(); } //使用enum关键字枚举类 enum Season1 implements Info{ //1.提供当前枚举类的对象，多个对象之间用\",\"隔开，末尾对象\";\"结束。必须在枚举类的第一行声明枚举类对象 SPRING(\"春天\",\"春暖花开\"){ @Override public void show() { System.out.println(\"春天在哪里？\"); } }, SUMMER(\"夏天\",\"夏日炎炎\"){ @Override public void show() { System.out.println(\"宁夏\"); } }, AUTUMN(\"秋天\",\"秋高气爽\"){ @Override public void show() { System.out.println(\"秋天不回来\"); } }, WINTER(\"冬天\",\"冰天雪地\"){ @Override public void show() { System.out.println(\"大约在冬季\"); } }; //2.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私有化类的构造器,并给对象属性赋值 private Season1(String seasonName,String seasonDesc){ this.seasonName = seasonName; this.seasonDesc = seasonDesc; } //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; } // //4.其他诉求1：提供toString() // // @Override // public String toString() { // return \"Season1{\" + // \"seasonName='\" + seasonName + '\\'' + // \", seasonDesc='\" + seasonDesc + '\\'' + // '}'; // } // @Override // public void show() { // System.out.println(\"这是一个季节\"); // } } # 2. 注解 Annotation 可用于修饰包，类，构造器，方法，成员变量，参数，局部变量的声明。 使用 Annotation 时要在其前面增加 @ 符号，并 把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素 自定义注解自动继承了 java.lang.annotation.Annotation 接口 没有成员定义的 Annotation 称为 标记；包含成员变量的 Annotation 称为元数据 Annotation /** * 注解的使用 * * 1. 理解Annotation: * ① jdk 5.0 新增的功能 * * ② Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation,程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。 * * ③在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android * 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗 * 代码和XML配置等。 * * 2. Annocation的使用示例 * 示例一：生成文档相关的注解 * 示例二：在编译时进行格式检查(JDK内置的三个基本注解) @Override: 限定重写父类方法, 该注解只能用于方法 @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择 @SuppressWarnings: 抑制编译器警告 * 示例三：跟踪代码依赖性，实现替代配置文件功能 * * 3. 如何自定义注解：参照@SuppressWarnings定义 * ① 注解声明为：@interface * ② 内部定义成员，通常使用value表示 * ③ 可以指定成员的默认值，使用default定义 * ④ 如果自定义注解没有成员，表明是一个标识作用。 * ⑤Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其 方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能 是八种基本数据类型、String 类型 、Class 类型 、enum 类型 、Annotation 类型 、 以上所有类型的数组。 如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是“参数名 = 参数值”，如果只有一个参数成员，且名称为value，可以省略“value=” 如果注解有成员，在使用注解时，需要指明成员的值。 自定义注解必须配上注解的信息处理流程(使用反射)才有意义。 自定义注解通过都会指明两个元注解：Retention、Target 4. jdk 提供的4种元注解 元注解：对现有的注解进行解释说明的注解 Retention：指定所修饰的 Annotation 的生命周期：SOURCE（在源文件中有效）\\CLASS（在class文件中有效）（默认行为）\\（在运行时有效）RUNTIME 只有声明为RUNTIME生命周期的注解，才能通过反射获取。 Target:用于指定被修饰的 Annotation 能用于修饰哪些程序元素 *******出现的频率较低******* Documented:表示所修饰的注解在被javadoc解析时，保留下来。定义为Documented的注解必须设置Retention值为RUNTIME Inherited:被它修饰的 Annotation 将具有继承性。如果某个类使用了被@Inherited 修饰的 Annotation, 则其子类将自动具有该注解 5.通过反射获取注解信息 ---到反射内容时系统讲解 6. jdk 8 中注解的新特性：可重复注解、类型注解 6.1 可重复注解：① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class ② MyAnnotation的Target和Retention等元注解与MyAnnotations相同。 6.2 类型注解： ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。 ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。 * * @author shkstart * @create 2019 上午 11:37 */ package com.atguigu.java1; import java.lang.annotation.*; import static java.lang.annotation.ElementType.*; /** * @author shkstart * @create 2019 上午 11:56 */ @Inherited @Repeatable(MyAnnotations.class) @Retention(RetentionPolicy.RUNTIME) @Target({TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE}) public @interface MyAnnotation { String value() default \"hello\"; } package com.atguigu.java1; import java.lang.annotation.Inherited; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import static java.lang.annotation.ElementType.*; /** * * @author shkstart * @create 2019 下午 2:41 */ @Inherited @Retention(RetentionPolicy.RUNTIME) @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE}) public @interface MyAnnotations { MyAnnotation[] value(); } public class AnnotationTest { public static void main(String[] args) { Person p = new Student(); p.walk(); Date date = new Date(2020, 10, 11); System.out.println(date); @SuppressWarnings(\"unused\") int num = 10; // System.out.println(num); @SuppressWarnings({ \"unused\", \"rawtypes\" }) ArrayList list = new ArrayList(); } @Test public void testGetAnnotation(){ Class clazz = Student.class; Annotation[] annotations = clazz.getAnnotations(); for(int i = 0;i &lt; annotations.length;i++){ System.out.println(annotations[i]); } } } //jdk 8之前的写法： //@MyAnnotations({@MyAnnotation(value=\"hi\"),@MyAnnotation(value=\"hi\")}) @MyAnnotation(value=\"hi\") @MyAnnotation(value=\"abc\") class Person{ private String name; private int age; public Person() { } @MyAnnotation public Person(String name, int age) { this.name = name; this.age = age; } @MyAnnotation public void walk(){ System.out.println(\"人走路\"); } public void eat(){ System.out.println(\"人吃饭\"); } } interface Info{ void show(); } class Student extends Person implements Info{ @Override public void walk() { System.out.println(\"学生走路\"); } public void show() { } } class Generic&lt;@MyAnnotation T&gt;{ public void show() throws @MyAnnotation RuntimeException{ ArrayList&lt;@MyAnnotation String&gt; list = new ArrayList&lt;&gt;(); int num = (@MyAnnotation int) 10L; } }","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"9-Java常用类","slug":"9-Java常用类","date":"2021-01-30T03:38:03.000Z","updated":"2022-10-30T01:33:03.163Z","comments":true,"path":"2021/01/30/9-java-chang-yong-lei/","link":"","permalink":"http://fsh010816.github.io/2021/01/30/9-java-chang-yong-lei/","excerpt":"","text":"# Java 常用类 # 1. 字符串相关的类 # 1.1 String # 1.1.1 String 的特性 1.String: 字符串，使用一对 \"\" 引起来表示。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。2.String 声明为 final 的，不可被继承。代表不可变的字符序列。 3.String 实现了 Serializable 接口：表示字符串是支持序列化的。 ​ 实现了 Comparable 接口：表示 String 可以比较大小 4.String 内部定义了 final char [] value 用于存储字符串数据 5.String: 代表不可变的字符序列。简称：不可变性。 ​ 体现：1. 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的 value 进行赋值。 ​ 2. 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。 ​ 3. 当调用 String 的 replace () 方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。 6. 通过字面量的方式（区别于 new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。 7. 字符串常量池中是不会存储相同内容的字符串的。 # 1.1.2 String 的实例化方式： 方式一：通过字面量定义的方式 方式二：通过 new + 构造器的方式 面试题：String s = new String (“abc”); 方式创建对象，在内存中创建了几个对象？ 两个：一个是堆空间中 new 结构，另一个是 char [] 对应的常量池中的数据：“abc” //通过字面量定义的方式：此时的s1和s2的数据javaEE声明在方法区中的字符串常量池中。 String s1 = \"javaEE\"; String s2 = \"javaEE\"; //通过new + 构造器的方式:此时的s3和s4保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。 String s3 = new String(\"javaEE\"); String s1 = \"javaEEhadoop\"; final String s4 = \"javaEE\";//s4:常量 String s5 = s4 + \"hadoop\"; System.out.println(s1 == s5);//true 1. 常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。 2. 只要其中有一个是变量，结果就在堆中。 3. 如果拼接的结果调用 intern () 方法，返回值就在常量池中 String s1 = new String(); String s2 = new String(\"\"); String s3 = \"\"; System.out.println(s1.equals(s2));//true System.out.println(s3.equals(s2));//true String 使用陷阱 String s1 = “a”; 说明：在字符串常量池中创建了一个字面量为 \"a\" 的字符串。 s1 = s1 + “b”; 说明：实际上原来的 “a” 字符串对象已经丢弃了，现在在堆空间中产生了一个字符串 s1+“b”（也就是 \"ab\")。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。 String s2 = “ab”; 说明：直接在字符串常量池中创建一个字面量为 \"ab\" 的字符串。 String s3 = “a” + “b”; 说明：s3 指向字符串常量池中已经创建的 \"ab\" 的字符串。 String s4 = s1.intern(); 说明：堆空间的 s1 对象在调用 intern () 之后，会将常量池中已经存在的 \"ab\" 字符串赋值给 s4。 # 1.1.3 String 常用方法 int length()：返回字符串的长度： return value.length char charAt(int index)： 返回某索引处的字符 return value [index] boolean isEmpty()：判断是否是空字符串：return value.length == 0 String toLowerCase()：使用默认语言环境，将 String 中的所有字符转换为小写 String toUpperCase()：使用默认语言环境，将 String 中的所有字符转换为大写 String trim()：返回字符串的副本，忽略前导空白和尾部空白 boolean equals(Object obj)：比较字符串的内容是否相同 boolean equalsIgnoreCase(String anotherString)：与 equals 方法类似，忽略大小写 String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用 “+” int compareTo(String anotherString)：比较两个字符串的大小 String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从 beginIndex 开始截取到最后的一个子字符串。 String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从 beginIndex 开始截取到 endIndex (不包含) 的一个子字符串。 boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束 boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始 boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始 boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引 int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始 int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引 int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索 注：indexOf 和 lastIndexOf 方法如果未找到都是返回 - 1 替换： String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。 String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 匹配： boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。 切片： String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。 String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过 limit 个，如果超过了，剩下的全部都放到最后一个元素中。 # 1.1.4 String 与字符数组转换 String 与 char [] 之间的转换 ①String --&gt; char []: 调用 String 的 toCharArray () : 将字符串中的全部字符存放在一个字符数组中的方法 public void getChars(int srcBegin, int srcEnd, char[] dst,int dstBegin) ：提供了将指定索引范围内的字符串存放到数组中的方法 ②char [] --&gt; String: 调用 String 的构造器 String(char[]) 和 和 String(char[] ，int offset ，int length) String str1 = \"abc123\"; char[] charArray = str1.toCharArray(); for (int i = 0; i &lt; charArray.length; i++) { System.out.println(charArray[i]); } # 1.1.5 String 与字节数组转换 /* String 与 byte[]之间的转换 编码：String --&gt; byte[]:调用String的getBytes() 解码：byte[] --&gt; String:调用String的构造器 String(byte[]) String(byte[] ，int offset ，int length) 编码：字符串 --&gt;字节 (看得懂 ---&gt;看不懂的二进制数据) 解码：编码的逆过程，字节 --&gt; 字符串 （看不懂的二进制数据 ---&gt; 看得懂） 说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。 */ @Test public void test3() throws UnsupportedEncodingException { String str1 = \"abc123中国\"; byte[] bytes = str1.getBytes();//使用默认的字符集，进行编码。 System.out.println(Arrays.toString(bytes)); byte[] gbks = str1.getBytes(\"gbk\");//使用gbk字符集进行编码。 System.out.println(Arrays.toString(gbks)); System.out.println(\"******************\"); String str2 = new String(bytes);//使用默认的字符集，进行解码。 System.out.println(str2); String str3 = new String(gbks); System.out.println(str3);//出现乱码。原因：编码集和解码集不一致！ String str4 = new String(gbks, \"gbk\"); System.out.println(str4);//没有出现乱码。原因：编码集和解码集一致！ } # 1.2 StringBuffer、StringBuilder 对比 String、StringBuffer、StringBuilder 三者的效率： 从高到低排列：StringBuilder &gt; StringBuffer &gt; String /* String、StringBuffer、StringBuilder三者的异同？ String:不可变的字符序列；底层使用char[]存储 StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储。作为参数传递时，方法内部可以改变值。 StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储 注意：作为参数传递的话，方法内部String不会改变其值，StringBuffer和StringBuilder会改变其值。 源码分析： String str = new String();//char[] value = new char[0]; String str1 = new String(\"abc\");//char[] value = new char[]{'a','b','c'}; StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。 System.out.println(sb1.length());// sb1.append('a');//value[0] = 'a'; sb1.append('b');//value[1] = 'b'; StringBuffer sb2 = new StringBuffer(\"abc\");//char[] value = new char[\"abc\".length() + 16]; //问题1. System.out.println(sb2.length());//3 //问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。 默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。 指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity) */ # 1.2.1 StringBuffer 的常用方法 StringBuffer append(xxx)：提供了很多的 append () 方法，用于进行字符串拼接 StringBuffer delete(int start,int end)：删除指定位置的内容 StringBuffer replace(int start, int end, String str)：把 [start,end) 位置替换为 str StringBuffer insert(int offset, xxx)：在指定位置插入 xxx StringBuffer reverse() ：把当前字符序列逆转 public int indexOf(String str) public String substring(int start,int end): 返回一个从 start 开始到 end 索引结束的左闭右开区间的子字符串 **public int length() ** public char charAt(int n ) public void setCharAt(int n ,char ch) # 1.2.2 String 和 StringBuffer、StringBuilder 的转换 String 转 StringBuffer、StringBuilder：调用 StringBuffer、StringBuilder 构造器 StringBuffer、StringBuilder 转 String：①调用 String 构造器②StringBuffer、StringBuilder 的 toString () # 2.JDK8 之前日期时间 API # 2.1 java.lang.System 类 long time = System.currentTimeMillis(); //返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。 //称为时间戳 System.out.println(time); # 2.2 java.util.Date 类 /* java.util.Date类 表示特定的瞬间，精确到毫秒 |---java.sql.Date类 1.两个构造器的使用 &gt;构造器一：Date()：创建一个对应当前时间的Date对象 &gt;构造器二：创建指定毫秒数的Date对象 2.两个方法的使用 &gt;toString():显示当前的年、月、日、时、分、秒 &gt;getTime():获取当前Date对象对应的毫秒数。（时间戳） 3. java.sql.Date对应着数据库中的日期类型的变量 &gt;如何实例化 &gt;如何将java.util.Date对象转换为java.sql.Date对象 */ @Test public void test2(){ //构造器一：Date()：创建一个对应当前时间的Date对象 Date date1 = new Date(); System.out.println(date1.toString());//Sat Feb 16 16:35:31 GMT+08:00 2019 System.out.println(date1.getTime());//1550306204104 //构造器二：创建指定毫秒数的Date对象 Date date2 = new Date(155030620410L); System.out.println(date2.toString()); //创建java.sql.Date对象 java.sql.Date date3 = new java.sql.Date(35235325345L); System.out.println(date3);//1971-02-13 //如何将java.util.Date对象转换为java.sql.Date对象 //情况一： // Date date4 = new java.sql.Date(2343243242323L); // java.sql.Date date5 = (java.sql.Date) date4; //情况二： Date date6 = new Date(); java.sql.Date date7 = new java.sql.Date(date6.getTime()); } # 2.3 java.text.SimpleDateFormat 类 /* SimpleDateFormat的使用：SimpleDateFormat对日期Date类的格式化和解析 1.两个操作： 1.1 格式化：日期 ---&gt;字符串 1.2 解析：格式化的逆过程，字符串 ---&gt; 日期 2.SimpleDateFormat的实例化 */ @Test public void testSimpleDateFormat() throws ParseException { //实例化SimpleDateFormat:使用默认的构造器 SimpleDateFormat sdf = new SimpleDateFormat(); //格式化：日期 ---&gt;字符串 Date date = new Date(); System.out.println(date); String format = sdf.format(date); System.out.println(format); //解析：格式化的逆过程，字符串 ---&gt; 日期 String str = \"19-12-18 上午11:43\"; Date date1 = sdf.parse(str); System.out.println(date1); //*************按照指定的方式格式化和解析：调用带参的构造器***************** // SimpleDateFormat sdf1 = new SimpleDateFormat(\"yyyyy.MMMMM.dd GGG hh:mm aaa\"); SimpleDateFormat sdf1 = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); //格式化 String format1 = sdf1.format(date); System.out.println(format1);//2019-02-18 11:48:27 //解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现), //否则，抛异常 Date date2 = sdf1.parse(\"2020-02-18 11:48:27\"); System.out.println(date2); } 字符串 \"2020-09-08\" 转换为 java.sql.Date @Test public void testExer() throws ParseException { String birth = \"2020-09-08\"; SimpleDateFormat sdf1 = new SimpleDateFormat(\"yyyy-MM-dd\"); Date date = sdf1.parse(birth); // System.out.println(date); java.sql.Date birthDate = new java.sql.Date(date.getTime()); System.out.println(birthDate); } # 2.4 java.util.Calendar (日历) 类 Calendar 是一个抽象基类，主用用于完成日期字段之间相互操作的功能。 @Test public void testCalendar(){ //1.实例化 //方式一：创建其子类（GregorianCalendar）的对象 //方式二：调用其静态方法getInstance() Calendar calendar = Calendar.getInstance(); // System.out.println(calendar.getClass()); /*2.常用方法一个Calendar的实例是系统时间的抽象表示，通过get(int field)方法来取得想要的时间信息。比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND */ //get() int days = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days); System.out.println(calendar.get(Calendar.DAY_OF_YEAR)); //set() //calendar可变性 calendar.set(Calendar.DAY_OF_MONTH,22); days = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days); //add() calendar.add(Calendar.DAY_OF_MONTH,-3); days = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days); //getTime():日历类---&gt; Date Date date = calendar.getTime(); System.out.println(date); //setTime():Date ---&gt; 日历类 Date date1 = new Date(); calendar.setTime(date1); days = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days); } 注意: 获取月份时：一月是 0，二月是 1，以此类推，12 月是 11 获取星期时：周日是 1，周二是 2 ， 。。。。周六是 7 # 3.JDK8 中新日期时间 API # 3.1 LocalDate、LocalTime、LocalDateTime 的使用 /* LocalDate、LocalTime、LocalDateTime 的使用 说明： 1.LocalDateTime相较于LocalDate、LocalTime，使用频率要高 2.类似于Calendar 3.它们的实例是不可变的对象 */ @Test public void test1(){ //now():获取当前的日期、时间、日期+时间 LocalDate localDate = LocalDate.now(); LocalTime localTime = LocalTime.now(); LocalDateTime localDateTime = LocalDateTime.now(); System.out.println(localDate); System.out.println(localTime); System.out.println(localDateTime); //of():设置指定的年、月、日、时、分、秒。没有偏移量 LocalDateTime localDateTime1 = LocalDateTime.of(2020, 10, 6, 13, 23, 43); System.out.println(localDateTime1); //getXxx()：获取相关的属性 System.out.println(localDateTime.getDayOfMonth()); System.out.println(localDateTime.getDayOfWeek()); System.out.println(localDateTime.getMonth()); System.out.println(localDateTime.getMonthValue()); System.out.println(localDateTime.getMinute()); //体现不可变性 //withXxx():设置相关的属性 LocalDate localDate1 = localDate.withDayOfMonth(22); System.out.println(localDate); System.out.println(localDate1); LocalDateTime localDateTime2 = localDateTime.withHour(4); System.out.println(localDateTime); System.out.println(localDateTime2); //不可变性 LocalDateTime localDateTime3 = localDateTime.plusMonths(3); System.out.println(localDateTime); System.out.println(localDateTime3); LocalDateTime localDateTime4 = localDateTime.minusDays(6); System.out.println(localDateTime); System.out.println(localDateTime4); } # 3.2 Instant 的使用 /* Instant的使用 时间线上的一个瞬时点。 类似于 java.util.Date类 */ @Test public void test2(){ //now():获取本初子午线对应的标准时间 Instant instant = Instant.now(); System.out.println(instant);//2019-02-18T07:29:41.719Z //添加时间的偏移量 OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8)); System.out.println(offsetDateTime);//2019-02-18T15:32:50.611+08:00 //toEpochMilli():获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数 ---&gt; Date类的getTime() long milli = instant.toEpochMilli(); System.out.println(milli); //ofEpochMilli():通过给定的毫秒数，获取Instant实例 --&gt;Date(long millis) Instant instant1 = Instant.ofEpochMilli(1550475314878L); System.out.println(instant1); } # 3.3 DateTimeFormatter: 格式化或解析日期、时间 /* DateTimeFormatter:格式化或解析日期、时间 类似于SimpleDateFormat */ @Test public void test3(){ // 方式一：预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME; //格式化:日期--&gt;字符串 LocalDateTime localDateTime = LocalDateTime.now(); String str1 = formatter.format(localDateTime); System.out.println(localDateTime); System.out.println(str1);//2019-02-18T15:42:18.797 //解析：字符串 --&gt;日期 TemporalAccessor parse = formatter.parse(\"2019-02-18T15:42:18.797\"); System.out.println(parse); // 方式二： // 本地化相关的格式。如：ofLocalizedDateTime() // FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG); //格式化 String str2 = formatter1.format(localDateTime); System.out.println(str2);//2019年2月18日 下午03时47分16秒 // 本地化相关的格式。如：ofLocalizedDate() // FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate DateTimeFormatter formatter2 = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM); //格式化 String str3 = formatter2.format(LocalDate.now()); System.out.println(str3);//2019-2-18 // 重点： 方式三：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”) DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern(\"yyyy-MM-dd hh:mm:ss\"); //格式化 String str4 = formatter3.format(LocalDateTime.now()); System.out.println(str4);//2019-02-18 03:52:09 //解析 TemporalAccessor accessor = formatter3.parse(\"2019-02-18 03:52:09\"); System.out.println(accessor); } # 3.4 与传统日期处理的转换 # 4.Java 比较器 自然排序：java.lang.Comparable 1.Comparable 接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。 2. 实现 Comparable 的类必须实现 compareTo (Object obj) 方法，两个对象即通过 compareTo (Object obj) 方法的返回值来比较大小。如果当前对象 this 大于形参对象 obj，则返回正整数，如果当前对象 this 小于形参对象 obj，则返回负整数，如果当前对象 this 等于形参对象 obj，则返回零。 3. 实现 Comparable 接口的对象列表（和数组）可以通过 Collections.sort 或 Arrays.sort 进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 4. 对于类 C 的每一个 e1 和 e2 来说，当且仅当 e1.compareTo (e2) == 0 与 e1.equals (e2) 具有相同的 boolean 值时，类 C 的自然排序才叫做与 equals 一致。建议（虽然不是必需的）最好使自然排序与 equals 一致。 Comparable 的典型实现：(默认都是从小到大排列的) 1.String：按照字符串中字符的 Unicode 值进行比较 2.Character：按照字符的 Unicode 值来进行比较 3. 数值类型对应的包装类以及 BigInteger、BigDecimal：按照它们对应的数值大小进行比较 4.Boolean：true 对应的包装类实例大于 false 对应的包装类实例 5.Date、Time 等：后面的日期时间比前面的日期时间大 Comparable 接口与 Comparator 的使用的对比： ①Comparable 接口的方式一旦一定，保证 Comparable 接口实现类的对象在任何位置都可以比较大小。 ②Comparator 接口属于临时性的比较。 public class CompareTest { /* Comparable接口的使用举例： 自然排序 1.像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。 2.像String、包装类重写compareTo()方法以后，进行了从小到大的排列 3. 重写compareTo(obj)的规则： 如果当前对象this大于形参对象obj，则返回正整数， 如果当前对象this小于形参对象obj，则返回负整数， 如果当前对象this等于形参对象obj，则返回零。 4. 对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。 在compareTo(obj)方法中指明如何排序 */ @Test public void test1(){ String[] arr = new String[]{\"AA\",\"CC\",\"KK\",\"MM\",\"GG\",\"JJ\",\"DD\"}; // Arrays.sort(arr); System.out.println(Arrays.toString(arr)); } @Test public void test2(){ Goods[] arr = new Goods[5]; arr[0] = new Goods(\"lenovoMouse\",34); arr[1] = new Goods(\"dellMouse\",43); arr[2] = new Goods(\"xiaomiMouse\",12); arr[3] = new Goods(\"huaweiMouse\",65); arr[4] = new Goods(\"microsoftMouse\",43); Arrays.sort(arr); System.out.println(Arrays.toString(arr)); } /* Comparator接口的使用：定制排序 1.背景： 当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码， 或者实现了java.lang.Comparable接口的排序规则不适合当前的操作， 那么可以考虑使用 Comparator 的对象来排序 2.重写compare(Object o1,Object o2)方法，比较o1和o2的大小： 如果方法返回正整数，则表示o1大于o2； 如果返回0，表示相等； 返回负整数，表示o1小于o2。 3.还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。 */ @Test public void test3(){ String[] arr = new String[]{\"AA\",\"CC\",\"KK\",\"MM\",\"GG\",\"JJ\",\"DD\"}; Arrays.sort(arr,new Comparator(){ //按照字符串从大到小的顺序排列 @Override public int compare(Object o1, Object o2) { if(o1 instanceof String &amp;&amp; o2 instanceof String){ String s1 = (String) o1; String s2 = (String) o2; return -s1.compareTo(s2); } // return 0; throw new RuntimeException(\"输入的数据类型不一致\"); } }); System.out.println(Arrays.toString(arr)); } @Test public void test4(){ Goods[] arr = new Goods[6]; arr[0] = new Goods(\"lenovoMouse\",34); arr[1] = new Goods(\"dellMouse\",43); arr[2] = new Goods(\"xiaomiMouse\",12); arr[3] = new Goods(\"huaweiMouse\",65); arr[4] = new Goods(\"huaweiMouse\",224); arr[5] = new Goods(\"microsoftMouse\",43); Arrays.sort(arr, new Comparator() { //指明商品比较大小的方式:按照产品名称从低到高排序,再按照价格从高到低排序 @Override public int compare(Object o1, Object o2) { if(o1 instanceof Goods &amp;&amp; o2 instanceof Goods){ Goods g1 = (Goods)o1; Goods g2 = (Goods)o2; if(g1.getName().equals(g2.getName())){ return -Double.compare(g1.getPrice(),g2.getPrice()); }else{ return g1.getName().compareTo(g2.getName()); } } throw new RuntimeException(\"输入的数据类型不一致\"); } }); System.out.println(Arrays.toString(arr)); } } //指明商品比较大小的方式:按照价格从低到高排序,再按照产品名称从高到低排序 @Override public int compareTo(Object o) { // System.out.println(\"**************\"); if(o instanceof Goods){ Goods goods = (Goods)o; //方式一： if(this.price &gt; goods.price){ return 1; }else if(this.price &lt; goods.price){ return -1; }else{ // return 0; return -this.name.compareTo(goods.name); } //方式二： // return Double.compare(this.price,goods.price); } // return 0; throw new RuntimeException(\"传入的数据类型不一致！\"); } # 5.System 类 由于该类的构造器是 private 的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是 static 的，所以也可以很方便的进行调用。 成员变量 : System 类内部包含 in、out 和 err 三个成员变量，分别代表标准输入流 (键盘输入)，标准输出流 (显示器) 和标准错误输出流 (显示器)。 成员方法: ① native long currentTimeMillis() ②void exit (int status)：该方法的作用是退出程序。其中 status 的值为 0 代表正常退出，非零代表异常退出。 使用该方法可以在图形界面编程中实现程序的退出功能等。 ③void gc () : 该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。 ④ String getProperty (String key) : 该方法的作用是获得系统中属性名为 key 的属性对应的值。系统中常见的属性名以及属性的作用如下表所示 # 6.Math 类 java.lang.Math 提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为 double 型。 abs 绝对值 acos,asin,atan,cos,sin,tan 三角函数 sqrt 平方根 pow (double a,doble b) a 的 b 次幂 log 自然对数 exp e 为底指数 max (double a,double b) min(double a,double b) random () 返回 0.0 到 1.0 的随机数 long round (double a) double 型数据 a 转换为 long 型（四舍五入） toDegrees (double angrad) 弧度 —&gt; 角度 toRadians (double angdeg) 角度 —&gt; 弧度 # 7.BigInteger 与 BigDecimal # 7.1 BigInteger java.math 包的 BigInteger 可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 构造器：BigInteger (String val)：根据字符串构建 BigInteger 对象 # 7.2 BigDecimal BigDecimal 类支持不可变的、任意精度的有符号十进制定点数。 构造器 ①public BigDecimal (double val) ②public BigDecimal (String val) 常用方法 public BigDecimal add(BigDecimal augend) public BigDecimal subtract(BigDecimal subtrahend) public BigDecimal multiply(BigDecimal multiplicand) public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"IDEA","slug":"IDEA","date":"2021-01-27T13:11:28.000Z","updated":"2022-10-28T08:47:48.907Z","comments":true,"path":"2021/01/27/idea/","link":"","permalink":"http://fsh010816.github.io/2021/01/27/idea/","excerpt":"","text":"# IDEA # 1.Project Module 在 project 下新建 Module # 1.1 删除模块 / 导入模块 再右键项目名删除 导入模块点加号 # 2. 配置 General # 2.1 主题 # 2.2 鼠标滚轮控制字体大小 # 2.3 鼠标悬浮提示 # 2.4 自动导包 # 2.5 行号 方法间的分隔符 # 2.6 忽略大小写提示 # 2.7 取消单行显示 tabs # 3. 配置 Font (字体) # 4. 类头的文档注释信息 # 5. 编码 # 6. 自动编译 # 7. 模板 自定义模板 先加一个 group, 在新加的 group 下添加模板 # 8. 在模块下导入 jar 包 在当前工程下新建一个 lib 文件夹 复制 jar 包到 lib 下 # 9.Debug 直接到下一个断点处 一行一行往下移 强制进入 出来","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"8-多线程","slug":"8-多线程","date":"2021-01-27T10:19:45.000Z","updated":"2022-10-27T15:10:56.074Z","comments":true,"path":"2021/01/27/8-duo-xian-cheng/","link":"","permalink":"http://fsh010816.github.io/2021/01/27/8-duo-xian-cheng/","excerpt":"","text":"# 多线程 # 1. 基本概念 程序：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象 进程：是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。 如：运行中的 QQ，运行中的 MP3 播放器 程序是静态的，进程是动态的 进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域 线程：进程可进一步细化为线程，是一个程序内部的一条执行路径。 1. 若一个进程同一时间并行执行多个线程，就是支持多线程的 2. 线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器 (pc)，线程切换的开销小 3. 一个进程中的多个线程共享相同的内存单元 / 内存地址空间→它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患 一个 Java 应用程序 java.exe，其实至少有三个线程：main () 主线程，gc () 垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。 并行：多个 CPU 同时执行多个任务。比如：多个人同时做不同的事。 并发：一个 CPU (采用时间片) 同时执行多个任务。比如：秒杀、多个人做同一件事。 进程可以细分为多个线程。 每个线程，拥有自己独立的：栈、程序计数器 多个线程，共享同一个进程中的结构：方法区、堆 多线程程序的优点： 提高应用程序的响应。对图形化界面更有意义，可增强用户体验。 提高计算机系统 CPU 的利用率 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改 何时需要多线程 程序需要同时执行两个或多个任务。 程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。 需要一些后台运行的程序时。 # 2. 线程的创建 每个线程都是通过某个特定 Thread 对象的 run () 方法来完成操作的，经常把 run () 方法的主体称为线程体。 如果自己手动调用 run () 方法，那么就只是普通方法，没有启动多线程模式。 run () 方法由 JVM 调用，什么时候调用，执行的过程控制都由操作系统的 CPU 调度决定。 Java 的调度方法 同优先级线程组成先进先出队列（先到先服务），使用时间片策略 对高优先级，使用优先调度的抢占式策略 Java 语言使用 Thread 类及其子类的对象来表示线程 # 2.1 多线程的创建方式一 /** * 多线程的创建，方式一：继承于Thread类 * 1. 创建一个继承于Thread类的子类 * 2. 重写Thread类的run() --&gt; 将此线程执行的操作声明在run()中 * 3. 创建Thread类的子类的对象 * 4. 通过此对象调用start() * 例子：遍历100以内的所有的偶数 * * @author shkstart * @create 2019-02-13 上午 11:46 */ //1. 创建一个继承于Thread类的子类 class MyThread extends Thread { //2. 重写Thread类的run() @Override public void run() { for (int i = 0; i &lt; 100; i++) { if(i % 2 == 0){ System.out.println(Thread.currentThread().getName() + \":\" + i); } } } } public class ThreadTest { public static void main(String[] args) { //3. 创建Thread类的子类的对象 MyThread t1 = new MyThread(); //4.通过此对象调用start():①启动当前线程 ② 调用当前线程的run() t1.start(); //问题一：我们不能通过直接调用run()的方式启动线程。 // t1.run(); //问题二：再启动一个线程，遍历100以内的偶数。不可以还让已经start()的线程去执行。会报IllegalThreadStateException // t1.start(); //我们需要重新创建一个线程的对象 MyThread t2 = new MyThread(); t2.start(); } } # 2.2 创建多线程的方式二 /** * 创建多线程的方式二：实现Runnable接口 * 1. 创建一个实现了Runnable接口的类 * 2. 实现类去实现Runnable中的抽象方法：run() * 3. 创建实现类的对象 * 4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 * 5. 通过Thread类的对象调用start() * * * 比较创建线程的两种方式。 * 开发中：优先选择：实现Runnable接口的方式 * 原因：1. 实现的方式没有类的单继承性的局限性 * 2. 实现的方式更适合来处理多个线程有共享数据的情况。 * * 联系：public class Thread implements Runnable * 相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。 * 要想启动线程，都是调用Thread类中的start() * @author shkstart * @create 2019-02-13 下午 4:34 */ //1. 创建一个实现了Runnable接口的类 class MThread implements Runnable{ //2. 实现类去实现Runnable中的抽象方法：run() @Override public void run() { for (int i = 0; i &lt; 100; i++) { if(i % 2 == 0){ System.out.println(Thread.currentThread().getName() + \":\" + i); } } } } public class ThreadTest1 { public static void main(String[] args) { //3. 创建实现类的对象 MThread mThread = new MThread(); //4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 Thread t1 = new Thread(mThread); t1.setName(\"线程1\"); //5. 通过Thread类的对象调用start():① 启动线程 ②调用当前线程的run()--&gt;调用了Runnable类型的target的run() t1.start(); //再启动一个线程，遍历100以内的偶数 Thread t2 = new Thread(mThread); t2.setName(\"线程2\"); t2.start(); } } # 2.3 Thread 中的常用方法 /** * 测试Thread中的常用方法： * 1. start():启动当前线程；调用当前线程的run() * 2. run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中 * 3. currentThread():静态方法，返回执行当前代码的线程。在Thread子类中就是this * 4. getName():获取当前线程的名字 * 5. setName():设置当前线程的名字 * 6. static void yield():释放当前cpu的执行权 * 7. join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才 * 结束阻塞状态。 * 8. stop():已过时。当执行此方法时，强制结束当前线程。 * 9. static void sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime * 毫秒时间内，当前线程是阻塞状态。 * 10. isAlive():判断当前线程是否存活 * * * 线程的优先级： * 1. * MAX_PRIORITY：10 * MIN _PRIORITY：1 * NORM_PRIORITY：5 --&gt;默认优先级 * 2.如何获取和设置当前线程的优先级： * getPriority():获取线程的优先级 * setPriority(int p):设置线程的优先级 * * 说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下 * 被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。 线程创建时继承父线程的优先级 * * * @author shkstart * @create 2019-02-13 下午 2:26 */ # 2.4 创建 Thread 类的匿名子类的方式 public class ThreadDemo { public static void main(String[] args) { //创建Thread类的匿名子类的方式 new Thread(){ @Override public void run() { for (int i = 0; i &lt; 100; i++) { if(i % 2 == 0){ System.out.println(Thread.currentThread().getName() + \":\" + i); } } } }.start(); new Thread(new Runnable() { @Override public void run() { for (int i = 0; i &lt; 100; i++) { if (i%2!=0){ System.out.println(Thread.currentThread().getName()+\":\"+i); } } } }).start(); } } # 2.5 线程的分类 一种是守护线程，一种是用户线程 1. 守护线程是用来服务用户线程的，通过在 start () 方法前调用 thread.setDaemon (true) 可以把一个用户线程变成一个守护线程。 2.Java 垃圾回收就是一个典型的守护线程。 3. 若 JVM 中都是守护线程，当前 JVM 将退出 # 3. 线程的生命周期 # 4. 线程的同步 # 4.1 同步代码块 同步方法 1、如何找问题，即代码是否存在线程安全 ？ （1）明确哪些代码是多线程运行的代码 （2）明确多个线程是否有共享数据 （3）明确多线程运行代码中是否有多条语句操作共享数据 2、如何解决呢？ 对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。即所有操作共享数据的这些语句都要放在同步范围中 3、 synchronized 的锁 同步方法的锁：静态方法（类名.class）、非静态方法（this） /** * 例子：创建三个窗口卖票，总票数为100张.使用实现Runnable接口的方式 * * 1.问题：卖票过程中，出现了重票、错票 --&gt;出现了线程的安全问题 * 2.问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。 * 3.如何解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他 * 线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。 * * * 4.在Java中，我们通过同步机制，来解决线程的安全问题。 * * 方式一：同步代码块 * * synchronized(同步监视器){ * //需要被同步的代码 * * } * 说明：1.操作共享数据的代码，即为需要被同步的代码。 --&gt;不能包含代码多了，也不能包含代码少了。 * 2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。 * 3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。 * 要求：多个线程必须要共用同一把锁。 * * 补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。 * 方式二：同步方法。 * 如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。 * * * 5.同步的方式，解决了线程的安全问题。---好处 * 操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 ---局限性 * * @author shkstart * @create 2019-02-13 下午 4:47 */ class Window1 implements Runnable{ private int ticket = 100; // Object obj = new Object(); // Dog dog = new Dog(); @Override public void run() { // Object obj = new Object(); while(true){ synchronized (this){//此时的this:唯一的Window1的对象 //方式二：synchronized (dog) { if (ticket &gt; 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \":卖票，票号为：\" + ticket); ticket--; } else { break; } } } } } public class WindowTest1 { public static void main(String[] args) { Window1 w = new Window1(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); } } class Dog{ } # 4.2 使用同步代码块，同步方法解决继承 Thread 类的方式的线程安全问题总结 /** * 使用同步代码块解决继承Thread类的方式的线程安全问题 * 说明：在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。 * 使用同步方法解决实现Runnable接口的线程安全问题 * 关于同步方法的总结： * 1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。 * 2. 非静态的同步方法，同步监视器是：this * 静态的同步方法，同步监视器是：当前类本身（类名.class） * * @author shkstart * @create 2019-02-15 上午 11:35 */ # 4.3 线程安全的单例模式中的懒汉式 public class BankTest { } class Bank{ private Bank(){} private static Bank instance = null; public static Bank getInstance(){ //方式一：效率稍差 // synchronized (Bank.class) { // if(instance == null){ // // instance = new Bank(); // } // return instance; // } //方式二：效率更高 if(instance == null){ synchronized (Bank.class) { if(instance == null){ instance = new Bank(); } } } return instance; } } # 4.4 解决线程安全问题的方式三：Lock (锁) java.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的工具。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是 ReentrantLock，可以显式加锁、释放锁 /** * 解决线程安全问题的方式三：Lock锁 --- JDK5.0新增 * * 1. 面试题：synchronized 与 Lock的异同？ * 相同：二者都可以解决线程安全问题 * 不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器 * Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()） * Lock只有代码块锁，synchronized有代码块锁和方法锁 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类） * * 2.优先使用顺序： * Lock →同步代码块（已经进入了方法体，分配了相应资源） → 同步方法（在方法体之外） * * * 面试题：如何解决线程安全问题？有几种方式 * @author shkstart * @create 2019-02-15 下午 3:38 */ class Window implements Runnable{ private int ticket = 100; //1.实例化ReentrantLock private ReentrantLock lock = new ReentrantLock(); @Override public void run() { while(true){ try{ //2.调用锁定方法lock() lock.lock(); if(ticket &gt; 0){ try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"：售票，票号为：\" + ticket); ticket--; }else{ break; } }finally { //3.调用解锁方法：unlock() lock.unlock(); } } } } # 4.5 不会释放锁的操作，释放锁的操作 不释放锁： 线程执行同步代码块或同步方法时，程序调用 Thread.sleep (Long l)、Thread.yield () 方法暂停当前线程的执行 线程执行同步代码块时，其它线程调用该线程 suspend () 方法将该线程挂起，该线程不会释放锁（同步监视器） ​ 尽量避免使用 suspend () 和 resume () 来控制线程 释放锁： 当前线程的同步方法、同步代码块执行结束 当前线程的同步方法、同步代码块遇到 break、return 终止该代码块、该方法的继续执行 当前线程的同步方法、同步代码块中出现了未处理 Error 和 Exception，导致异常结束 当前线程在同步方法、同步代码块中执行了线程对象的 wait () 方法，当前线程暂停，并释放锁# # 4.6 死锁 死锁 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续 解决方法 专门的算法、原则 尽量减少同步资源的定义 尽量避免嵌套同步 # 5. 线程的通信 /** * 线程通信的例子：使用两个线程打印 1-100。线程1, 线程2 交替打印 * * 涉及到的三个方法： * wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。 对象名.wait() * notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。 对象名.notify() * notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。 * * 说明： * 1.wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。 * 2.wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。 * 否则，会出现IllegalMonitorStateException异常 * 3.wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。 * * 面试题：sleep() 和 wait()的异同？ * 1.相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。 * 2.不同点：1）两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait() * 2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中 * 3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。 * * @author shkstart * @create 2019-02-15 下午 4:21 */ class Number implements Runnable{ private int number = 1; private Object obj = new Object(); @Override public void run() { while(true){ synchronized (obj) { obj.notify(); if(number &lt;= 100){ try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \":\" + number); number++; try { //使得调用如下wait()方法的线程进入阻塞状态 obj.wait(); } catch (InterruptedException e) { e.printStackTrace(); } }else{ break; } } } } } # 5.1 生产者 / 消费者问题 package com.atguigu.java2; /** * 线程通信的应用：经典例题：生产者/消费者问题 * * 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品， * 店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员 * 会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品 * 了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。 * * 分析： * 1. 是否是多线程问题？是，生产者线程，消费者线程 * 2. 是否有共享数据？是，店员（或产品） * 3. 如何解决线程的安全问题？同步机制,有三种方法 * 4. 是否涉及线程的通信？是 * * @author shkstart * @create 2019-02-15 下午 4:48 */ class Clerk{ private int productCount = 0; //生产产品 public synchronized void produceProduct() { if(productCount &lt; 20){ productCount++; System.out.println(Thread.currentThread().getName() + \":开始生产第\" + productCount + \"个产品\"); notify(); }else{ //等待 try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } //消费产品 public synchronized void consumeProduct() { if(productCount &gt; 0){ System.out.println(Thread.currentThread().getName() + \":开始消费第\" + productCount + \"个产品\"); productCount--; notify(); }else{ //等待 try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } class Producer extends Thread{//生产者 private Clerk clerk; public Producer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { System.out.println(getName() + \":开始生产产品.....\"); while(true){ try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } clerk.produceProduct(); } } } class Consumer extends Thread{//消费者 private Clerk clerk; public Consumer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { System.out.println(getName() + \":开始消费产品.....\"); while(true){ try { Thread.sleep(20); } catch (InterruptedException e) { e.printStackTrace(); } clerk.consumeProduct(); } } } public class ProductTest { public static void main(String[] args) { Clerk clerk = new Clerk(); Producer p1 = new Producer(clerk); p1.setName(\"生产者1\"); Consumer c1 = new Consumer(clerk); c1.setName(\"消费者1\"); Consumer c2 = new Consumer(clerk); c2.setName(\"消费者2\"); p1.start(); c1.start(); c2.start(); } } # 6.JDK5.0 新增线程创建方式 # 6.1 新增方式三：实现 Callable 接口 /** * 创建线程的方式三：实现Callable接口。 --- JDK 5.0新增 * * * 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？ * 1. call()可以有返回值的。 * 2. call()可以抛出异常，被外面的操作捕获，获取异常的信息 * 3. Callable是支持泛型的 * 4. 需要借助FutureTask类，比如获取返回结果 * * @author shkstart * @create 2019-02-15 下午 6:01 */ //1.创建一个实现Callable的实现类 class NumThread implements Callable{ //2.实现call方法，将此线程需要执行的操作声明在call()中 @Override public Object call() throws Exception { int sum = 0; for (int i = 1; i &lt;= 100; i++) { if(i % 2 == 0){ System.out.println(i); sum += i; } } return sum; } } public class ThreadNew { public static void main(String[] args) { //3.创建Callable接口实现类的对象 NumThread numThread = new NumThread(); //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象 FutureTask futureTask = new FutureTask(numThread); //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start() new Thread(futureTask).start(); try { //6.获取Callable中call方法的返回值 //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。 Object sum = futureTask.get(); System.out.println(\"总和为：\" + sum); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } } # 6.2 创建线程的方式四：使用线程池 /** * 创建线程的方式四：使用线程池 * * 好处： * 1.提高响应速度（减少了创建新线程的时间） * 2.降低资源消耗（重复利用线程池中线程，不需要每次都创建） * 3.便于线程管理 * corePoolSize：核心池的大小 * maximumPoolSize：最大线程数 * keepAliveTime：线程没有任务时最多保持多长时间后会终止 * * * 面试题：创建多线程有几种方式？四种！ * @author shkstart * @create 2019-02-15 下午 6:30 */ class NumberThread implements Runnable{ @Override public void run() { for(int i = 0;i &lt;= 100;i++){ if(i % 2 == 0){ System.out.println(Thread.currentThread().getName() + \": \" + i); } } } } class NumberThread1 implements Runnable{ @Override public void run() { for(int i = 0;i &lt;= 100;i++){ if(i % 2 != 0){ System.out.println(Thread.currentThread().getName() + \": \" + i); } } } } public class ThreadPool { public static void main(String[] args) { //1. 提供指定线程数量的线程池 ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor // Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池 ExecutorService service = Executors.newFixedThreadPool(10); ThreadPoolExecutor service1 = (ThreadPoolExecutor) service; //设置线程池的属性 // System.out.println(service.getClass()); // service1.setCorePoolSize(15); // service1.setKeepAliveTime(); //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象 service.execute(new NumberThread());//适合适用于Runnable service.execute(new NumberThread1());//适合适用于Runnable // service.submit(Callable callable);//适合使用于Callable //3.关闭连接池 service.shutdown(); } }","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"7-异常处理","slug":"7-异常处理","date":"2021-01-23T08:40:04.000Z","updated":"2022-10-23T06:07:02.397Z","comments":true,"path":"2021/01/23/7-yi-chang-chu-li/","link":"","permalink":"http://fsh010816.github.io/2021/01/23/7-yi-chang-chu-li/","excerpt":"","text":"# 异常处理 # 1. 异常体系结构 Error:Java 虚拟机无法解决的严重问题。如：JVM 系统内部错误、资源耗尽等严重情况。比如：StackOverflowError 和 OOM。一般不编写针对性的代码进行处理。 Exception： 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。 /* * 一、异常体系结构 * * java.lang.Throwable * |-----java.lang.Error:一般不编写针对性的代码进行处理。（非受检异常） * |-----java.lang.Exception:可以进行异常的处理 * |------编译时异常(checked) * |-----IOException * |-----FileNotFoundException * |-----ClassNotFoundException * |------运行时异常(unchecked,RuntimeException) * |-----NullPointerException * |-----ArrayIndexOutOfBoundsException * |-----ClassCastException * |-----NumberFormatException * |-----InputMismatchException * |-----ArithmeticException * */ # 2. 异常处理机制一：try-catch-finally # 2.1 异常的处理：抓抛模型 过程一：“抛”：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出（该异常对象将被提交给 Java 运行时系统）。 一旦抛出对象以后，其后的代码就不再执行。 关于异常对象的产生：① 系统自动生成的异常对象② 手动的生成一个异常对象，并抛出（throw） ①由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，如果在当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出 —— 自动抛出 ②由开发人员手动创建：Exception exception = new ClassCastException ();—— 创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样 throw new RuntimeException(\"您输入的数据非法！\"); 过程二：“抓”：可以理解为异常的处理方式：① try-catch-finally ② throws 如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理。如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法。这个过程将一直继续下去，直到异常被处理。这一过程称为捕获 (catch) 异常。 如果一个异常回到 main () 方法，并且 main () 也不处理，则程序运行终止。 不捕获异常时的情况： ①前面使用的异常都是 RuntimeException 类或是它的子类，这些类的异常的特点是：即使没有使用 try 和 catch 捕获，Java 自己也能捕获，并且编译通过 (但运行时会发生异常使得程序运行终止)。 ②如果抛出的异常是 IOException 等类型的非运行时异常，则必须捕获，否则编译错误。也就是说，我们必须处理编译时异常，将异常进行捕捉，转化为运行时异常 # 2.2 try-catch-finally 的使用 try{ //可能出现异常的代码 }catch(异常类型1 变量名1){ //处理异常的方式1 }catch(异常类型2 变量名2){ //处理异常的方式2 }catch(异常类型3 变量名3){ //处理异常的方式3 } .... finally{ //一定会执行的代码 } 说明： 1.finally 是可选的。 2. 使用 try 将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去 catch 中进行匹配 3. 一旦 try 中的异常对象匹配到某一个 catch 时，就进入 catch 中进行异常的处理。一旦处理完成，就跳出当前的 try-catch 结构（在没有写 finally 的情况）。继续执行其后的代码 4.catch 中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。catch 中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错 5. 常用的异常对象处理的方式： ① String getMessage () ② printStackTrace () 6. 在 try 结构中声明的变量，在出了 try 结构以后，就不能再被调用 7.try-catch-finally 结构可以嵌套 8. 不论在 try 代码块中是否发生了异常事件，catch 语句是否执行，catch 语句是否有异常，catch 语句中是否有 return，finally 块中的语句都会被执行。 体会 1：使用 try-catch-finally 处理编译时异常，使得程序在编译时就不再报错，但是运行时仍可能报错。 相当于我们使用 try-catch-finally 将一个编译时可能出现的异常，延迟到运行时出现。 体会 2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写 try-catch-finally 了。 针对于编译时异常，我们说一定要考虑异常的处理。 # 2.2.1 try-catch-finally 中 finally 的使用： 1.finally 是可选的 2.finally 中声明的是一定会被执行的代码。即使 catch 中又出现异常了，try 中有 return 语句，catch 中有 return 语句等情况。 3. 像数据库连接、输入输出流、网络编程 Socket 等资源，JVM 是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在 finally 中。 # 3. 异常处理的方式二：声明抛出异常 如果一个方法 (中的语句执行时) 可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。 1.\"throws + 异常类型\" 写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。 一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足 throws 后异常 类型时，就会被抛出。异常代码后续的代码，就不再执行！ 2. 体会：try-catch-finally: 真正的将异常给处理掉了。 throws 的方式只是将异常抛给了方法的调用者。 并没有真正将异常处理掉。 3. 开发中如何选择使用 try-catch-finally 还是使用 throws？ 3.1 如果父类中被重写的方法没有 throws 方式处理异常，则子类重写的方法也不能使用 throws，意味着如果 子类重写的方法中有异常，必须使用 try-catch-finally 方式处理。 3.2 执行的方法 a 中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用 throws 的方式进行处理。而执行的方法 a 可以考虑使用 try-catch-finally 方式进行处理。 # 3.1 方法重写的规则之一： 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型 重写方法不能抛出比被重写方法范围更大的异常类型。在多态的情况下，对 methodA () 方法的调用 - 异常的捕获按父类声明的异常处理。 # 4. 手动抛出异常 Java 异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要使用人工创建并抛出 。 首先要生成异常类对象，然后通过 throw 语句实现抛出操作 (提交给 Java 运行环境)。 IOException e = new IOException(); throw e; 可以抛出的异常必须是 Throwable 或其子类的实例。下面的语句在编译时将会产生语法错误： throw new String(\"want to throw\"); # 5. 如何自定义异常类？ /* * 如何自定义异常类？ * 1. 继承于现有的异常结构：RuntimeException 、Exception * 2. 提供全局常量：serialVersionUID * 3. 提供重载的构造器 * */ public class MyException extends Exception{ static final long serialVersionUID = -7034897193246939L; public MyException(){ } public MyException(String msg){ super(msg); } } 自定义的异常通过 throw 抛出。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"6-面向对象(下)","slug":"6-面向对象-下","date":"2021-01-21T08:15:45.000Z","updated":"2022-10-21T03:26:48.236Z","comments":true,"path":"2021/01/21/6-mian-xiang-dui-xiang-xia/","link":"","permalink":"http://fsh010816.github.io/2021/01/21/6-mian-xiang-dui-xiang-xia/","excerpt":"","text":"# 面向对象 (下) # 1.static 当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过 new 关键字才会产生出对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用。 # 1.1 static 关键字的使用 1.static: 静态的 2.static 可以用来修饰：属性、方法、代码块、内部类 3. 使用 static 修饰属性：静态变量（或类变量） 3.1 属性，按是否使用 static 修饰，又分为：静态属性 vs 非静态属性 (实例变量) 实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。 静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。 3.2 static 修饰属性的其他说明： ① 静态变量随着类的加载而加载。可以通过 \"类。静态变量\" 的方式进行调用 ② 静态变量的加载要早于对象的创建。 ③ 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。 ④ 类变量 实例变量 类 yes no 对象 yes yes 类不能直接调用实例变量 ⑤静态变量和静态方法前省略的是 “类.” 3.3 静态属性举例：System.out; Math.PI; 4. 使用 static 修饰方法：静态方法 ① 随着类的加载而加载，可以通过 \"类。静态方法\" 的方式进行调用 ② 静态方法 非静态方法 类 yes no 对象 yes yes ③ 静态方法中，只能调用静态的方法或属性 非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性 5.static 注意点： 5.1 在静态的方法内，不能使用 this 关键字、super 关键字 5.2 关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。 5.3 static 修饰的方法不能被重写 6. 开发中，如何确定一个属性是否要声明为 static 的？ 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。 类中的常量也常常声明为 static 开发中，如何确定一个方法是否要声明为 static 的？ 操作静态属性的方法，通常设置为 static 的 工具类中的方法，习惯上声明为 static 的。 比如：Math、Arrays、Collections # 1.2 内存解析 # 1.3 单例 (Singleton) 设计模式 单例设计模式： 1. 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。 2. 如何实现？ 饿汉式 vs 懒汉式 3. 区分饿汉式 和 懒汉式 饿汉式： 坏处：对象加载时间过长。 好处：饿汉式是线程安全的 懒汉式：好处：延迟对象的创建。 目前的写法坏处：线程不安全。—&gt; 到多线程内容时，再修改 4. 单例模式的优点： 由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。 //饿汉式 class Bank{ //1.私有化类的构造器 private Bank(){ } //2.内部创建类的对象 //4.要求此对象也必须声明为静态的 private static Bank instance = new Bank(); //3.提供公共的静态的方法，返回类的对象 public static Bank getInstance(){ return instance; } } //懒汉式 未考虑线程安全 class Order{ //1.私有化类的构造器 private Order(){ } //2.声明当前类对象，没有初始化 //4.此对象也必须声明为static的 private static Order instance = null; //3.声明public、static的返回当前类对象的方法 public static Order getInstance(){ if(instance == null){ instance = new Order(); } return instance; } } # 1.3.1 应用场景 # 2. 理解 main 方法的语法 main () 方法的使用说明： 1.main () 方法作为程序的入口 2.main () 方法也是一个普通的静态方法 3.main () 方法可以作为我们与控制台交互的方式。（之前：使用 Scanner） 由于 Java 虚拟机需要调用类的 main () 方法，所以该方法的访问权限必须是 public，又因为 Java 虚拟机在执行 main () 方法时不必创建对象，所以该方法必须是 static 的，该方法接收一个 String 类型的数组参数，该数组中保存执 Java 命令时传递给所运行的类的参数。 因为 main () 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员 # 3. 代码块 代码块（或初始化块） 1. 代码块的作用：用来初始化类、对象 2. 代码块如果有修饰的话，只能使用 static. 3. 分类：静态代码块 vs 非静态代码块 4. 静态代码块 ①内部可以有输出语句 ②随着类的加载而执行，而且只执行一次 ③作用：初始化类的信息。 初始化 static 的属性 ④如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行 ⑤静态代码块的执行要优先于非静态代码块的执行 ⑥静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构 5. 非静态代码块 ①内部可以有输出语句 ②随着对象的创建而执行 ③每创建一个对象，就执行一次非静态代码块。且先于构造器执行。 ④作用：可以在创建对象时，对对象的属性等进行初始化 ⑤如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行 ⑥非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法 所有的静态代码块 然后是各个类的非静态代码块和构造器 // 总结：由父及子，静态先行 # 4. 对属性可以赋值的位置： ①默认初始化 ②显式初始化 /⑤在代码块中赋值 ③构造器中初始化 ④有了对象以后，可以通过 \"对象。属性\" 或 \"对象。方法\" 的方式，进行赋值 执行的先后顺序：① - ② / ⑤ - ③ - ④ # 5.final 1.final 可以用来修饰的结构：类、方法、变量 2.final 用来修饰一个类：此类不能被其他类所继承。 比如：String 类、System 类、StringBuffer 类 3.final 用来修饰方法：表明此方法不可以被重写 比如：Object 类中 getClass (); 4.final 用来修饰变量（成员变量或局部变量）：此时的 \"变量\" 就称为是一个常量 4.1 final 修饰属性：可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化（必须先赋值，然后才能使用） 构造器后对象就产生了，堆空间中相应的属性就加载了，用 final 修饰的属性就要有值了 4.2 final 修饰局部变量： 尤其是使用 final 修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。 static final 用来修饰属性：全局常量 # 6.abstract 关键字的使用 1.abstract: 抽象的 2.abstract 可以用来修饰的结构：类、方法 3.abstract 修饰类：抽象类 抽象类是用来模型化那些父类无法确定全部实现，而是由其子类提供具体实现的对象的类。 此类不能实例化 抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程） 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 4.abstract 修饰方法：抽象方法 public abstract void eat(); 抽象方法只有方法的声明，没有方法体 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。 若子类重写了父类中的所有的抽象方法后，此子类方可实例化 若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用 abstract 修饰 abstract 使用上的注意点： 1.abstract 不能用来修饰：属性、构造器等结构 不能用 abstract 修饰变量、代码块、构造器； 2.abstract 不能用来修饰私有方法、静态方法、final 的方法、final 的类 # 6.1 抽象类的匿名子类 //Person是抽象类 创建了一匿名子类的对象：p Person p = new Person(){ @Override public void eat() { System.out.println(\"吃东西\"); } @Override public void breath() { System.out.println(\"好好呼吸\"); } }; public static void main(String[] args) { //创建匿名子类的匿名对象 method1(new Person(){ @Override public void eat() { System.out.println(\"吃好吃东西\"); } @Override public void breath() { System.out.println(\"好好呼吸新鲜空气\"); } }); } public static void method1(Person p){ p.eat(); p.breath(); } # 6.2 模板方法设计模式 (TemplateMethod) 当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。 换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。 /* * 抽象类的应用：模板方法的设计模式 * */ public class TemplateTest { public static void main(String[] args) { SubTemplate t = new SubTemplate(); t.spendTime(); } } abstract class Template{ //计算某段代码执行所需要花费的时间 public void spendTime(){ long start = System.currentTimeMillis(); this.code();//不确定的部分、易变的部分 long end = System.currentTimeMillis(); System.out.println(\"花费的时间为：\" + (end - start)); } public abstract void code(); } class SubTemplate extends Template{ @Override public void code() { for(int i = 2;i &lt;= 1000;i++){ boolean isFlag = true; for(int j = 2;j &lt;= Math.sqrt(i);j++){ if(i % j == 0){ isFlag = false; break; } } if(isFlag){ System.out.println(i); } } } } # 6.2.1 应用 # 7. 接口 1. 接口使用 interface 来定义 2.Java 中，接口和类是并列的两个结构 3. 如何定义接口：定义接口中的成员 接口中的所有成员变量都默认是由 public static final 修饰的。 接口中的所有抽象方法都默认是由 public abstract 修饰的。 3.1 JDK7 及以前：只能定义全局常量和抽象方法 全局常量：public static final 的。但是书写时，可以省略不写 抽象方法：public abstract 的 可省略或之省略 public 3.2 JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法 4. 接口中不能定义构造器的！意味着接口不可以实例化 5.Java 开发中，接口通过让类去实现 (implements) 的方式来使用. 如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化 如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类 6.Java 类可以实现多个接口 —&gt; 弥补了 Java 单继承性的局限性 格式：class AA extends BB implements CC,DD,EE 7. 接口与接口之间可以继承，而且可以多继承 8. 接口的具体使用，体现多态性。接口与实现类之间存在多态性 9. 接口，实际上可以看做是一种规范。继承是一个 \"是不是\" 的关系，而接口实现则是 \"能不能\" 的关系。 10. 静态方法：使用 static 关键字修饰。可以通过接口直接调用静态方法，并执行其方法体 11. 默认方法：默认方法使用 default 关键字修饰。可以通过实现类对象来调用。 12. 接口的主要用途就是被实现类实现。（面向接口编程） # 7.1 接口的应用：代理模式 (Proxy) 概述：代理设计就是为其他对象提供一种代理以控制对这个对象的访问。 /* * 接口的应用：代理模式 * */ public class NetWorkTest { public static void main(String[] args) { Server server = new Server(); // server.browse(); ProxyServer proxyServer = new ProxyServer(server); proxyServer.browse(); } } interface NetWork{ public void browse(); } //被代理类 class Server implements NetWork{ @Override public void browse() { System.out.println(\"真实的服务器访问网络\"); } } //代理类 class ProxyServer implements NetWork{ private NetWork work; public ProxyServer(NetWork work){ this.work = work; } public void check(){ System.out.println(\"联网之前的检查工作\"); } @Override public void browse() { check(); work.browse(); } } # 7.1.1 应用场景： # 7.2 接口的使用 1. 接口使用上也满足多态性 2. 接口，实际上就是定义了一种规范 3. 开发中，体会面向接口编程！ public class USBTest { public static void main(String[] args) { Computer com = new Computer(); //1.创建了接口的非匿名实现类的非匿名对象 Flash flash = new Flash(); com.transferData(flash); //2. 创建了接口的非匿名实现类的匿名对象 com.transferData(new Printer()); //3. 创建了接口的匿名实现类的非匿名对象 USB phone = new USB(){ @Override public void start() { System.out.println(\"手机开始工作\"); } @Override public void stop() { System.out.println(\"手机结束工作\"); } }; com.transferData(phone); //4. 创建了接口的匿名实现类的匿名对象 com.transferData(new USB(){ @Override public void start() { System.out.println(\"mp3开始工作\"); } @Override public void stop() { System.out.println(\"mp3结束工作\"); } }); } } class Computer{ public void transferData(USB usb){//USB usb = new Flash(); usb.start(); System.out.println(\"具体传输数据的细节\"); usb.stop(); } } interface USB{ //常量：定义了长、宽、最大最小的传输速度等 void start(); void stop(); } class Flash implements USB{ @Override public void start() { System.out.println(\"U盘开启工作\"); } @Override public void stop() { System.out.println(\"U盘结束工作\"); } } class Printer implements USB{ @Override public void start() { System.out.println(\"打印机开启工作\"); } @Override public void stop() { System.out.println(\"打印机结束工作\"); } } # 7.3 笔试题 interface A { int x = 0; } class B { int x = 1; } class C extends B implements A { public void pX() { //编译不通过。因为x是不明确的 // System.out.println(x); System.out.println(super.x);//1 System.out.println(A.x);//0 } public static void main(String[] args) { new C().pX(); } } # 7.4 Java8 中关于接口的改进 JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法 public interface CompareA { //静态方法 public static void method1(){ System.out.println(\"CompareA:北京\"); } //默认方法 public default void method2(){ System.out.println(\"CompareA：上海\"); } default void method3(){ System.out.println(\"CompareA：上海\"); } } public interface CompareB { default void method3(){ System.out.println(\"CompareB：上海\"); } } public class SuperClass { public void method3(){ System.out.println(\"SuperClass:北京\"); } } public class SubClassTest { public static void main(String[] args) { SubClass s = new SubClass(); // s.method1(); // SubClass.method1(); //知识点1：接口中定义的静态方法，只能通过接口来调用。 CompareA.method1(); //知识点2：通过实现类的对象，可以调用接口中的默认方法。 //如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法 s.method2(); //知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法， //那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。--&gt;类优先原则 //知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法， //那么在实现类没有重写此方法的情况下，报错。--&gt;接口冲突。 //这就需要我们必须在实现类中重写此方法 s.method3(); } } class SubClass extends SuperClass implements CompareA,CompareB{ public void method2(){ System.out.println(\"SubClass：上海\"); } public void method3(){ System.out.println(\"SubClass：深圳\"); } //知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法 public void myMethod(){ method3();//调用自己定义的重写的方法 super.method3();//调用的是父类中声明的 //调用接口中的默认方法 CompareA.super.method3(); CompareB.super.method3(); } } # 7.5 接口和抽象类之间的对比 # 8. 内部类 1. 非 static 的成员内部类中的成员不能声明为 static 的。只有在外部类或 static 的成员内部类中才可声明 static 成员。 2. 如何使用局部内部类 2.1 只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类 2.2 但是它的对象可以通过外部方法的返回值返回使用，返回值类型只能是局部内部类的父类或父接口类型 3. 匿名内部类不能定义任何静态成员、静态方法和静态类，只能创建匿名内部类的一个实例。 4. 外部类访问成员内部类的成员，需要 “内部类。成员” 或 “内部类对象。成员” 的方式 package com.atguigu.java2; /* * 类的内部成员之五：内部类 * 1. Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类 * * 2.内部类的分类：成员内部类（静态、非静态） vs 局部内部类(方法内、代码块内、构造器内) * * 3.成员内部类： * 一方面，作为外部类的成员： * &gt;调用外部类的结构 * &gt;可以被static修饰 * &gt;可以被4种不同的权限修饰 * * 另一方面，作为一个类： * &gt; 类内可以定义属性、方法、构造器等 * &gt; 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承 * &gt; 可以被abstract修饰，因此可以被其它的内部类继承 * * * 4.关注如下的3个问题 * 4.1 如何实例化成员内部类的对象 * 4.2 如何在成员内部类中区分调用外部类的结构 * 4.3 开发中局部内部类的使用 见《InnerClassTest1.java》 * */ public class InnerClassTest { public static void main(String[] args) { //创建Dog实例(静态的成员内部类): Person.Dog dog = new Person.Dog(); dog.show(); //创建Bird实例(非静态的成员内部类): // Person.Bird bird = new Person.Bird();//错误的 Person p = new Person(); Person.Bird bird = p.new Bird(); bird.sing(); System.out.println(); bird.display(\"黄鹂\"); } } class Person{ String name = \"小明\"; int age; public void eat(){ System.out.println(\"人：吃饭\"); } //静态成员内部类 static class Dog{ String name; int age; public void show(){ System.out.println(\"卡拉是条狗\"); // eat(); } } //非静态成员内部类 class Bird{ String name = \"杜鹃\"; public Bird(){ } public void sing(){ System.out.println(\"我是一只小小鸟\"); Person.this.eat();//调用外部类的非静态属性 eat(); System.out.println(age); } public void display(String name){ System.out.println(name);//方法的形参 System.out.println(this.name);//内部类的属性 System.out.println(Person.this.name);//外部类的属性 } } public void method(){ //局部内部类 class AA{ } } { //局部内部类 class BB{ } } public Person(){ //局部内部类 class CC{ } } } package com.atguigu.java2; public class InnerClassTest1 { //开发中很少见 public void method(){ //局部内部类 class AA{ } } //返回一个实现了Comparable接口的类的对象 public Comparable getComparable(){ //创建一个实现了Comparable接口的类:局部内部类 //方式一： // class MyComparable implements Comparable{ // // @Override // public int compareTo(Object o) { // return 0; // } // // } // // return new MyComparable(); //方式二：匿名内部类 return new Comparable(){ @Override public int compareTo(Object o) { return 0; } }; } } 成员内部类和局部内部类在编译以后，都会生成字节码文件 成员内部类：外部类 $ 内部类名.class 局部内部类：外部类名 $ 数字内部类名.class 在局部内部类的方法中（比如：show）如果调用局部内部类所声明的方法 (比如：method) 中的局部变量 (比如：num) 的话，要求此局部变量声明为 final 的。由局部内部类和局部变量的声明周期不同所致（局部变量是在外部类的字节码文件中，局部内部类是另一个字节码文件）。 局部内部类可以使用外部方法的局部变量，但是必须是 final 的。 局部内部类可以使用外部类的成员，包括私有的。 局部内部类和局部变量地位类似，不能使用 public,protected, 缺省，private 局部内部类不能使用 static 修饰，因此也不能包含静态成员 jdk 7 及之前版本：要求此局部变量显式的声明为 final 的 jdk 8 及之后的版本：可以省略 final 的声明 public void method(){ int num = 10; class AA{ public void show(){ System.out.println(num); } } }","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"5-面向对象(中)","slug":"5-面向对象-中","date":"2021-01-19T12:34:49.000Z","updated":"2022-10-20T04:29:42.127Z","comments":true,"path":"2021/01/19/5-mian-xiang-dui-xiang-zhong/","link":"","permalink":"http://fsh010816.github.io/2021/01/19/5-mian-xiang-dui-xiang-zhong/","excerpt":"","text":"# 面向对象 (中) # 1. 继承性 # 1.1 好处 1. 继承的出现减少了代码冗余，提高了代码的复用性。 2. 继承的出现，更有利于功能的扩展。 3. 继承的出现让类与类之间产生了关系，提供了多态的前提。 # 1.2 格式 class A extends B{} //A:子类、派生类、subclass B:父类、超类、基类、superclass 2.1 体现：一旦子类 A 继承父类 B 以后，子类 A 中就获取了父类 B 中声明的所有的属性和方法。特别的，父类中声明为 private 的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。只有因为封装性的影响，使得子类不能直接调用父类的结构而已。 2.2 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。子类和父类的关系，不同于子集和集合的关系。extends：延展、扩展 三、Java 中关于继承性的规定： 1. 一个类可以被多个子类继承。 2.Java 中类的单继承性：一个类只能有一个父类 3. 子父类是相对的概念。 4. 子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类 5. 子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法 四、 1. 如果我们没有显式的声明一个类的父类的话，则此类继承于 java.lang.Object 类 2. 所有的 java 类（除 java.lang.Object 类之外）都直接或间接的继承于 java.lang.Object 类 3. 意味着，所有的 java 类具有 java.lang.Object 类声明的功能。 # 2. 重写 # 2.1 定义 在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。 # 2.2 规定 方法的声明： 权限修饰符 返回值类型 方法名(形参列表) throws 异常的类型{ //方法体 } 约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法 ① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同 ② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符 特殊情况：子类不能重写父类中声明为 private 权限的方法 ③ 返回值类型： 父类被重写的方法的返回值类型是 void，则子类重写的方法的返回值类型只能是 void 父类被重写的方法的返回值类型是 A 类型，则子类重写的方法的返回值类型可以是 A 类或 A 类的子类 父类被重写的方法的返回值类型是基本数据类型 (比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型 (必须也是 double) ④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型 子类和父类中的同名同参数的方法要么都声明为非 static 的（考虑重写），要么都声明为 static 的（不是重写）。因为 static 方法是属于类的，子类无法覆盖父类的方法。 # 3.super # 3.1 super 关键字的使用 1.super 理解为：父类的 super 的追溯不仅限于直接父类 2.super 可以用来调用：属性、方法、构造器 3.super 的使用：调用属性和方法 3.1 我们可以在子类的方法或构造器中。通过使用 \"super. 属性\" 或 \"super. 方法\" 的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略 \"super.\" 3.2 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用 \"super. 属性\" 的方式，表明调用的是父类中声明的属性。 3.3 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用 \"super. 方法\" 的方式，表明调用的是父类中被重写的方法。 4.super 调用构造器 4.1 我们可以在子类的构造器中显式的使用 \"super (形参列表)\" 的方式，调用父类中声明的指定的构造器 4.2 \"super (形参列表)\" 的使用，必须声明在子类构造器的首行！ 4.3 我们在类的构造器中，针对于 \"this (形参列表)\" 或 \"super (形参列表)\" 只能二选一，不能同时出现 4.4 在构造器的首行，没有显式的声明 \"this (形参列表)“或\"super (形参列表)”，则默认调用的是父类中空参的构造器：super () 4.5 在类的多个构造器中，至少有一个类的构造器中使用了 \"super (形参列表)\"，调用父类中的构造器 4.6 如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错 4.7 当父类中没有空参数的构造器时，子类的构造器必须通过 this (参数列表) 或者 super ( 参数列表) 语句指定调用本类或者父类中相应的构造器。 # 3.2 this 和 super 的区别 为什么 super (…) 和 this (…) 只能作为构造器的第一句出现？ 答：无论通过哪个构造器创建子类对象，需要保证先初始化父类。 目的：当子类继承父类后，“继承 \" 父类中所有的属性和方法，因此子类有必要知道父类如何为对象进行初始化。 # 4. 子类对象实例化的全过程 1. 从结果上来看：（继承性） 子类继承父类以后，就获取了父类中声明的属性或方法。 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。 2. 从过程上来看： 当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，… 直到调用了 java.lang.Object 类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。 明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为 new 的子类对象。 # 5. 多态性 1. 何为多态性： 对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用） Person p2=new Man();//Man是Person的子类 Man man = new Man(); Person p = man;//也是多态性 可以直接应用在抽象类和接口上 2. 多态的使用：虚拟方法调用 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。 子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。 总结：编译，看左边；运行，看右边。 “看左边”：看的是父类的引用（父类中不具备子类特有的方法） “看右边”： 看的是子类的对象（实际运行的是子类重写父类的方法） 3. 多态性的使用前提： ① 类的继承关系 ② 方法的重写 4. 对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边） 5.Java 引用变量有两个类型： 编译时类型和 运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简称：编译时，看左边；运行时，看右边。 若编译时类型和运行时类型不一致 ， 就出现了对象的多态性 （Polymorphism） 多态是运行时行为 6. 一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法。属性是在编译时确定的 7. 若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中：编译看左边，运行看右边 8. 对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量：编译运行都看左边 一个变量只能有一种确定的数据类型 一个引用类型变量可能指向 (引用) 多种不同类型的对象 Object o = new Person();//Object类型的变量o，指向Person类型的对象 10. 对象的多态 — 在 Java 中，子类的对象可以替代父类的对象使用 子类可看做是特殊的父类 ， 所以父类类型的引用可以指向子类的对象：向上转型 (upcasting)。 11. 方法声明的形参类型为父类类型，可以使用子类的对象作为实参调用该方法 12. 多态性的理解： ①实现代码的通用性 ②抽象类、接口的使用肯定体现了多态性（抽象类、接口不能实例化） # 5.1 方法的重载与重写 二者的定义细节：略 从编译和运行的角度看： 重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java 的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。 所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为 “早绑定” 或 “静态绑定”； 而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为 “晚绑定” 或 “动态绑定”。 # 5.2 instanceof ①有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。 ②a instanceof A: 判断对象 a 是否是类 A 的实例。如果是，返回 true；如果不是，返回 false。 要求 a 所属的类与类 A 必须是子类和父类的关系，否则编译错误 如果 a 属于类 A 的子类 B，a instanceof A 值也为 true ③使用情境：为了避免在向下转型时出现 ClassCastException 的异常，我们在向下转型之前，先进行 instanceof 的判断，一旦返回 true，就进行向下转型。如果返回 false，不进行向下转型。 # 5.3 对象类型转换 (Casting) 对 Java 对象的强制类型转换称为造型 从子类到父类的类型转换可以自动进行 从父类到子类的类型转换必须通过造型 (强制类型转换) 实现 无继承关系的引用类型间的转换是非法的 在造型前可以使用 instanceof 操作符测试一个对象的类型 # 6.java.lang.Object 类 1.Object 类是所有 Java 类的根父类 2. 如果在类的声明中未使用 extends 关键字指明其父类，则默认父类为 java.lang.Object 类 3.Object 类中的功能 (属性、方法) 就具有通用性。 属性：无 方法：equals () /toString () /getClass () /hashCode () /clone () /finalize ()、wait () 、 notify ()、notifyAll () 4.Object 类只声明了一个空参的构造器 5. 数组的父类也是 Object # 6.1 == equals() # 6.1.1 == == ：运算符 1. 可以使用在基本数据类型变量和引用数据类型变量中 2. 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同） 如果比较的是引用数据类型变量：比较两个对象的地址值是否相同。即两个引用是否指向同一个对象实体 补充： == 符号使用时，必须保证符号左右两边的变量类型一致。 char c = 10; int i = 10; System.out.println(i==c); //true # 6.1.2 equals () 方法的使用 1. 是一个方法，而非运算符 2. 只能适用于引用数据类型 3.Object 类中 equals () 的定义： public boolean equals(Object obj) { return (this == obj); } 说明：Object 类中定义的 equals () 和 == 的作用是相同的：比较两个对象的地址值是否相同。即两个引用是否指向同一个对象实体 4. 像 String、Date、File、包装类等都重写了 Object 类中的 equals () 方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的 \"实体内容\" 是否相同。 5. 通常情况下，我们自定义的类如果使用 equals () 的话，也通常是比较两个对象的 \"实体内容\" 是否相同。那么，我们就需要对 Object 类中的 equals () 进行重写. 重写的原则：比较两个对象的实体内容是否相同. # 6.2 toString() 1. 当我们输出一个对象的引用时，实际上就是调用当前对象的 toString () String s = \"abc\"; s = null; System.out.println(s);//null System.out.println(s.toString());//空指针异常 2.Object 类中 toString () 的定义： public String toString() { return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); } 3. 像 String、Date、File、包装类等都重写了 Object 类中的 toString () 方法。使得在调用对象的 toString () 时，返回 \"实体内容\" 信息 4. 自定义类也可以重写 toString () 方法，当调用此方法时，返回对象的 \"实体内容\" 5.toString () 方法在 Object 类中定义 ，其返回值是 String 类型 ， 返回类名和它的引用地址 。 6. 在进行 String 与其它类型数据的连接操作时 ，自动调用 toString () 方法 Date now=new Date(); System.out.println(“now=”+now); //相当于 System.out.println(“now=”+now.toString()); 7. 基本类型数据转换为 String 类型时 ，调用了对应包装类的 toString () 方法 int a=10; System.out.println(“a=”+a); # 7. 包装类 java 提供了 8 种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征 # 7.1 String 类型 —&gt; 基本数据类型、包装类 String 类型 —&gt; 基本数据类型、包装类：调用包装类的 parseXxx (String s) String str1 = \"123\"; int num2 = Integer.parseInt(str1); 通过包装类的构造器实现: int i = new Integer(“12”); # 7.2 基本数据类型、包装类 —&gt;String 类型 基本数据类型、包装类 —&gt;String 类型：调用 String 重载的 valueOf (Xxx xxx) int num1 = 10; //方式1：连接运算 String str1 = num1 + \"\"; //方式2：调用String的valueOf(Xxx xxx) float f1 = 12.3f; String str2 = String.valueOf(f1);//\"12.3\" //包装类---&gt;String类型 String s1 = Integer.toString(314); // s1= “314“ 将数字转换成字符串 # 7.3 基本数据类型 —&gt; 包装类 基本数据类型 —&gt; 包装类：调用包装类的构造器 int num1 = 10; Integer in1 = new Integer(num1); System.out.println(in1.toString()); Integer in2 = new Integer(\"123\"); //通过字符串参数构造包装类对象 System.out.println(in2.toString()); Boolean b3 = new Boolean(\"true123\"); System.out.println(b3);//false Boolean b2 = new Boolean(\"TrUe\"); System.out.println(b2);//true 自动装箱：基本数据类型 —&gt; 包装类 int num2 = 10; Integer in1 = num2;//自动装箱 int num3 = in1;//自动拆箱 # 7.4 包装类 —&gt; 基本数据类型 包装类 —&gt; 基本数据类型：调用包装类 Xxx 的 xxxValue () Integer in1 = new Integer(12); int i1 = in1.intValue(); 自动拆箱：包装类 —&gt; 基本数据类型 # 7.5 面试题 //Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[], //保存了从-128~127范围的整数。如果我们使用自动装箱的方式，给Integer赋值的范围在 //-128~127范围内时，可以直接使用数组中的元素，不用再去new了。目的：提高效率 Integer m = 1; Integer n = 1; System.out.println(m == n);//true Integer x = 128;//相当于new了一个Integer对象 Integer y = 128;//相当于new了一个Integer对象 System.out.println(x == y);//false # 7.6 总结","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"4-面向对象(上)","slug":"4-面向对象-上","date":"2021-01-18T07:02:37.000Z","updated":"2022-10-19T09:39:03.883Z","comments":true,"path":"2021/01/18/4-mian-xiang-dui-xiang-shang/","link":"","permalink":"http://fsh010816.github.io/2021/01/18/4-mian-xiang-dui-xiang-shang/","excerpt":"","text":"# 面向对象 (上) # 1. 面向过程与面向对象 1. 面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。 2. 面向对象：将功能封装进对象，强调具备了功能的对象，以类 / 对象为最小单位，考虑谁来做。 # 1.1 理解 “万事万物皆对象” 1. 在 Java 语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构 2. 涉及到 Java 语言与前端 Html、后端的数据库交互时，前后端的结构在 Java 层面交互时，都体现为类、对象。 # 2. 类 (Class) 和对象 (Object) 类是对一类事物的描述，是抽象的、概念上的定义 对象是实际存在的该类事物的每个个体，因而也称为实例 (instance)。 # 2.1 类的成员 1 &gt; 属 性：对应类中的成员变量 2 &gt; 行 为：对应类中的成员方法 Field = 属性 = 成员变量 = 域、字段，Method = (成员) 方法 = 函数 创建类的对象 = 类的实例化 = 实例化类 # 2.2 类的语法格式 修饰符 class 类名 { 属性声明; 方法声明; } 类的正文要用 { } 括起来 # 3. 类和对象的使用 1. 创建类，设计类的成员 2. 创建类的对象 类名 对象名 = new 类名(); 3. 通过 “对象。属性” 或 “对象。方法” 调用对象的结构 说明：如果创建了一个类的多个对象，对于类中定义的属性，每个对象都拥有各自的一套副本，且互不干扰。 类的访问机制: 1. 在一个类中的访问机制：类中的方法可以直接访问类中的成员变量 。（例外：static 方法访问非 static，编译不通过） 2. 在不同类中的访问机制：先创建要访问类的对象 ，再用对象访问类中定义的成员 。 # 3.1 内存解析 编译完程序以后，生成一个或多个字节码文件， 我们使用 JVM 中的类的加载器和解释器对生成的字节码文件进行解释运行，意味着，需要将字节码文件对应的类加载到内存中，涉及到内存解析。 堆 (heap)： 存放对象实例 对象的属性（非 static）new 出来的结构 对象（非 static 成员变量）数组 栈 (stack)： 存储局部变量 方法区（Method Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 常量池 静态域 # 3.2 对象的内存解析 引用类型的变量，只可能存储两类值：null 或 地址值（含变量的类型） Person p2 = p1;//没有新创建一个对象，共用一个堆空间的对象实体。将p1变量保存的对象地址值赋给p2,导致p1和p2指向了堆空间中的同一个对象实体。 # 3.3 匿名对象 我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。 如：new Person ().shout (); 使用情况 1. 如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。 2. 我们经常将匿名对象作为实参传递给一个方法调用。 # 4. 类的成员之一：属性 (field) 属性语法格式: 修饰符 数据类型 属性名 = 初始化值; 说明：修饰符 ①、常用的权限修饰符有：private、缺省、protected、public ②、其他修饰符：static、final (暂不考虑) # 4.1 成员变量与局部变量 在方法体外，类体内声明的变量称为成员变量。 在方法体内部声明的变量称为局部变量。 对象属性的默认初始化赋值：当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值。 # 4.1.1 相同点 1. 定义变量的格式：数据类型 变量名 = 变量值 2. 先声明，后使用 3. 变量都有其对应的作用域 # 4.1.2 不同点 1. 在类中声明的位置不同 成员变量：在方法体外，类体内声明的变量。直接定义在类的一对 {} 内 局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量 2. 关于权限修饰符的不同 （修饰符） 属性：可以在声明属性时，指明其权限，使用权限修饰符 ​ private、public、缺省、protected （static 、final） 局部变量：不可使用权限修饰符 （可以用 final） 3. 默认初始化值 属性：根据其类型，都有默认初始化值 局部变量：没有默认初始化值 ​ 调用局部变量前，必须显示赋值 ​ 特别地，形参在调用时，赋值即可 4. 在内存中加载的位置 属性：堆（非 static） 或 静态域内 局部变量：栈 # 5. 方法 Java 里的方法不能独立存在，所有的方法必须定义在类里。 # 5.1 声明 修饰符 返回值类型 方法名 （参数类型 形参1,参数类型 形参2, …）｛ 方法体程序代码 return 返回值; ｝ 返回值类型： ​ 没有返回值：void。 如果使用 return, 只能 \"return;\"，表示结束此方法的意思 ​ 有返回值，声明出返回值的类型。 return 关键字的使用：①结束方法 ②针对于有返回值类型的方法，使用 \"return 数据\" 方法返回所要的数据。 返回值：方法在执行完毕后返还给调用它的程序的数据。 方法的调用：方法通过方法名被调用，且只有被调用才会执行。 # 5.2 注意 方法的使用中，可以调用当前类的属性或方法（例外：static 方法访问非 static，编译不通过 。） 特殊的：方法 A 中又调用了方法 A: 递归方法。 方法中，不可以定义方法 定义方法时，方法的结果应该返回给调用者，交由调用者处理。 # 5.2.1 四舍五入取整 四舍五入取整：Math.round (double d)，返回值类型 long。 # 5.3 重载 概念：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。 “两同一不同”: 同一个类、相同方法名 参数列表不同：参数个数不同，参数类型不同 重载的特点：与返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。 //下面2个构成形参 public void getSum(String s ,int i){ System.out.println(\"3\"); } public void getSum(int i,String s){ System.out.println(\"4\"); } # 5.3.1 面试题 int[] arr = new int[]{1,2,3}; System.out.println(arr); //[I@1540e19d char[] arr1 = new char[]{'a','b','c'}; System.out.println(arr1); //abc char[] arr4 = new char[10]; System.out.print(arr4); System.out.println(1);// 1 # 5.4 可变个数的形参 JavaSE 5.0 中提供了 Varargs (variable number of arguments) 机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。 public static void test(int a ,String…books){} 1. 声明格式：方法名 (参数的类型名 … 参数名) 此参数名也有 length 属性 2. 可变参数：方法参数部分指定类型的参数个数是可变多个：0 个，1 个或多个 3. 可变参数方法的使用与方法参数部分使用数组是一致的 4. 可变个数形参的方法与同名的方法之间，彼此构成重载 5. 方法的参数部分有可变形参，需要放在形参声明的最后。在一个方法的形参位置，最多只能声明一个可变个数形参 6. 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。 # 5.5 方法参数的值传递机制 形参：方法声明时的参数 方法定义时，声明的小括号内的参数 实参：方法调用时实际传给形参的参数值 Java 里方法的参数传递方式只有一种：值传递。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。 1 &gt; 形参是基本数据类型：将实参基本数据类型变量的 “数据值” 传递给形参 2 &gt; 形参是引用数据类型：将实参引用数据类型变量的 “地址值” 传递给形参 # 6. 封装和隐藏 高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉； 低耦合 ：仅对外暴露少量的方法用于使用。 # 6.1 信息的封装和隐藏 Java 中通过将数据声明为私有的 (private)，再提供公共的（public）方法:getXxx () 和 setXxx () 实现对该属性的操作，以实现下述目的： 1. 隐藏一个类中不需要对外提供的实现细节； 2. 使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作； 3. 便于修改，增强代码的可维护性 # 6.2 体现 1. 将类的属性私有化，同时，提供公共的方法来获取 (get) 和设置 (set) 此属性的值 2. 不对外暴露的私有的方法 3. 单例模式 (将构造器私有化) # 6.3 权限修饰符 4 种权限修饰符都可以修饰类的内部结构：属性、方法、构造器、内部类 修饰类，只能用：缺省和 public # 7. 构造器 # 7.1 构造器的特征 它具有与类相同的名称 它不声明返回值类型。（与声明为 void 不同） 不能被 static、final、synchronized、abstract、native 修饰，不能有 return 语句返回值 # 7.2 构造器的作用 创建对象；给对象进行初始化 如：Order o = new Order (); Person p = new Person (“Peter”,15); # 7.3 语法格式 ： 修饰符名 类名 (参数列表) { 初始化语句； } 根据参数不同，构造器可以分为如下两类： 1. 隐式无参构造器（系统默认提供） 2. 显式定义一个或多个（无参、有参） # 7.4 注意： Java 语言中，每个类都至少有一个构造器 如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器 默认构造器的修饰符与所属类的修饰符一致 一旦显式定义了构造器，则系统不再提供默认构造器 一个类可以创建多个重载的构造器 父类的构造器不可被子类继承 # 7.5 属性赋值过程 赋值的位置： ① 默认初始化 ② 显式初始化 ③ 构造器中初始化 ④ 通过 “对象。属性 “或 “对象。方法” 的方式赋值 赋值的先后顺序：① - ② - ③ - ④ # 7.6 JavaBean JavaBean 是一种 Java 语言写成的可重用组件。 所谓 javaBean，是指符合如下标准的 Java 类： 1. 类是公共的 2. 有一个无参的公共的构造器 3. 有属性，且有对应的 get、set 方法 用户可以使用 JavaBean 将功能、处理、值、数据库访问和其他任何可以用 Java 代码创造的对象进行打包，并且其他的开发者可以通过内部的 JSP 页面、Servlet、其他 JavaBean、applet 程序或者应用来使用这些对象。用户可以认为 JavaBean 提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。 # 8.this this 关键字的使用： 1.this 可以用来修饰、调用：属性、方法、构造器 2.this 修饰属性和方法： this 理解为：当前对象 或 当前正在创建的对象 2.1 在类的方法中，我们可以使用 \"this. 属性\" 或 \"this. 方法\" 的方式，调用当前对象属性或方法。但是，通常情况下，我们都选择省略 \"this.\"。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用 \"this. 变量\" 的方式，表明此变量是属性，而非形参。 2.2 在类的构造器中，我们可以使用 \"this. 属性\" 或 \"this. 方法\" 的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都选择省略 \"this.\"。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用 \"this. 变量\" 的方式，表明此变量是属性，而非形参。 2.3 使用 this 访问属性和方法时，如果在本类中未找到，会从父类中查找 3.this 调用构造器 ① 我们在类的构造器中，可以显式的使用 \"this (形参列表)\" 方式，调用本类中指定的其他构造器 ② 构造器中不能通过 \"this (形参列表)\" 方式调用自己 ③ 如果一个类中有 n 个构造器，则最多有 n - 1 构造器中使用了 \"this (形参列表)\" ④ 规定：\"this (形参列表)\" 必须声明在当前构造器的首行 ⑤ 构造器内部，最多只能声明一个 \"this (形参列表)\"，用来调用其他的构造器 # 9.package package 语句作为 Java 源文件的第一条语句，指明该文件中定义的类所在的包。(若缺省该语句，则指定为无名包)。它的格式为： package 顶层包名.子包名; 同一个包下，不能命名同名的接口、类。 包对应于文件系统的目录，package 语句中，用 \".\" 来指明包 (目录) 的层次； 包的作用: 包帮助管理大型软件系统：将功能相近的类划分到同一个包中。比如：MVC 的设计模式 包可以包含类和子包，划分项目层次，便于管理 解决类命名冲突的问题 控制访问权限 # 9.1MVC # 9.2 jdk 中主要的包介绍 # 10.import 在源文件中使用 import 显式的导入指定包下的类或接口 如果已经导入 java.a 包下的类。那么如果需要使用 a 包的子包下的类的话，仍然需要导入。使用 \"xxx.*\" 方式表明可以调用 xxx 包下的所有结构。但是如果使用的是 xxx 子包下的结构，则仍需要显式导入 import static 组合的使用：调用指定类或接口下的静态的属性或方法 如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示。 如果使用的类或接口是 java.lang 包下定义的，则可以省略 import 结构 如果使用的类或接口是本包下定义的，则可以省略 import 结构 import static java.lang.System.*; out.println(\"hello\"); java.sql.Date date1 = new java.sql.Date(5243523532535L); 7.import 语句告诉编译器到哪里去寻找类。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"3-数组","slug":"3-数组","date":"2021-01-13T13:47:11.000Z","updated":"2022-10-19T01:23:01.025Z","comments":true,"path":"2021/01/13/3-shu-zu/","link":"","permalink":"http://fsh010816.github.io/2021/01/13/3-shu-zu/","excerpt":"","text":"# 数组 # 1. 数组的概述 1. 数组的理解：数组 (Array)，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。 2. 数组相关的概念： 数组名 元素 角标、下标、索引 数组的长度：元素的个数 3. 数组的特点 1 &gt; 数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括基本数据类型和引用数据类型。 2 &gt; 创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址。 3 &gt; 数组的长度一旦确定，就不能修改。 4 &gt; 数组是有序排列的 4. 数组的分类： ① 按照维数：一维数组、二维数组、。。。 ② 按照数组元素的类型：基本数据类型元素的数组、引用数据类型元素的数组 # 2. 一维数组 # 2.1 声明 type var[] 或 type[] var; Java 语言中声明数组时不能指定其长度 (数组中元素的数) 例如：int a [5];// 非法 # 2.2 初始化 # 2.2.1 静态初始化 静态初始化 ：在定义数组的同时就为数组元素分配空间并赋值。 int arr[] = new int[]{ 3, 9, 8}; 或 int[] arr = {3,9,8};//类型推断，声明和赋值要在一行 String[] s = new String[]{\"\",\"\",\"\"}; String[] s1 = new String[3]; System.out.println(Arrays.toString(s)); //[, , ] System.out.println(Arrays.toString(s1));//[null, null, null] System.out.println(s1.length);//3 System.out.println(s.length);//3 int[] i = new int[]{}; int[] i1 = new int[]{,}; int[] i2 = new int[0]; System.out.println(Arrays.toString(i));//[] System.out.println(Arrays.toString(i1));//[] System.out.println(Arrays.toString(i2));//[] System.out.println(i1[0]); //java.lang.ArrayIndexOutOfBoundsException System.out.println(i.length); //0 System.out.println(i1.length);//0 System.out.println(i2.length);//0 # 2.2.2 动态初始化 动态初始化 ：数组声明且为数组元素分配空间与赋值的操作分开进行 int[] arr = new int[3]; arr[0] = 3; arr[1] = 9; arr[2] = 8; # 2.3 数组元素的引用 定义并用运算符 new 为之分配空间后，才可以引用数组中的每个元素 数组元素的调用方式：数组名 [数组元素下标]。数组元素下标可以是整型常量或整型表达式 数组元素下标从 0 开始 每个数组都有一个属性 length 指明它的长度，数组一旦初始化，其长度是不可变的 # 2.4 数组元素的默认初始化值 数组是引用类型，它的元素相当于类的成员变量，因此数组一经分配空间，其中的每个元素也被按照成员变量同样的方式被隐式初始化 # 2.5 内存解析 下图目前这么理解 # 3. 多维数组 对于二维数组的理解，我们可以看成是一维数组 array1 又作为另一个一维数组 array2 的元素而存在。 # 3.1 二维数组的声明和初始化 静态初始化 int[][] arr = new int[][]{{3,8,2},{2,7},{9,0,1,6}}; System.out.println(arr.length); //3 System.out.println(arr[1].length); //2 int[][] arr = {{3,8,2},{2,7},{9,0,1,6}};//类型推断，只能一行时使用 注意特殊写法情况：int [] x,y []; x 是一维数组，y 是二维数组。 动态初始化 1 int[][] arr = new int[3][2]; System.out.println(arr[0]); //一维数组地址 System.out.println(arr[0][0]); //0 动态初始化 2 int[][] arr = new int[3][]; System.out.println(arr[0]); //null int[][] arr = new int[][3];//非法 # 3.2 数组元素的默认初始化值 针对于初始化方式一：比如： int[][] arr = new int[4][3]; 外层元素的初始化值为：地址值 内层元素的初始化值为：与一维数组初始化情况相同 针对于初始化方式二：比如： int[][] arr = new int[4][]; 外层元素的初始化值为：null 内层元素的初始化值为：不能调用，否则报错。 引用类型的变量要么是 null，要么是地址值 # 3.3 内存解析 # 4. 数组中涉及到的常见算法 # 4.1 数组的赋值 int[] array1,array2; array1 = new int[]{2,3,5,7,11,13,17,19}; //赋值array2变量等于array1。array1和array2地址值相同，都指向了堆空间的唯一的一个数组实体。 array2 = array1; # 4.2 数组的反转 String[] arr = new String[]{\"JJ\",\"DD\",\"MM\",\"BB\",\"GG\",\"AA\"}; //数组的反转 String temp; for (int i = 0; i &lt; arr.length / 2; i++) { temp = arr[i]; arr[i] = arr[arr.length-i-1]; arr[arr.length-i-1] = temp; } # 4.3 二分法查找 前提：所要查找的数组有序 int arr1[] = new int[]{-98,-77,-55,-22,0,1,23,34,54,66,77,88,99}; int dest = 2; int head = 0; //初始的首索引 int end = arr1.length - 1; //初始的末索引 boolean isFlag = true; while(head &lt;= end){ //注意是 &lt;=,=表示首索引和尾索引指向同一个数，即首尾索引指出的数组长度为1 int middle = (head+end)/2; if(dest == arr1[middle]){ System.out.println(\"找到了，位置:\"+middle); isFlag = false; break; }else if(arr1[middle] &gt; dest){ end = middle - 1; }else{ head = middle + 1; } } if(isFlag){ System.out.println(\"没找到\"); } # 4.4 排序算法 # 4.4.1 衡量排序算法的优劣 1. 时间复杂度 2. 空间复杂度 3. 稳定性：若两个记录 A 和 B 的关键字值相等，但排序后 A、B 的先后次序保持不变，则称这种排序算法是稳定的。 # 4.4.2 分类 排序算法分类： 内部排序 和 外部排序 。 内部排序：整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。 外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。 # 4.4.3 冒泡排序 排序思想： 比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。 int arr[] = new int[]{22,33,11,-99,0,62,21}; //冒泡排序 for(int i = 0;i &lt; arr.length-1;i++){ for(int j = 0;j&lt;arr.length-1-i;j++){ if(arr[j]&gt;arr[j+1]){ int temp = arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } } for(int i = 0;i&lt;arr.length;i++){ System.out.print(arr[i]+\" \"); } # 4.4.4 快速排序 # 5.Arrays 工具类的使用 java.util.Arrays 1 boolean equals (int [] a,int [] b) 判断两个数组是否相等。 2 String toString (int [] a) 输出数组信息。 3 void fill (int [] a,int val) 将指定值填充到数组之中。 4 void sort (int [] a) 对数组进行排序。 5 int binarySearch (int [] a,int key) 对排序后的数组进行二分法检索指定的值。 # 6. 数组使用中的常见异常 数组脚标越界异常 (ArrayIndexOutOfBoundsException) 空指针异常 (NullPointerException) // 空指针异常：NullPointerException //情况一： // int[] arr1 = new int[]{1,2,3}; // arr1 = null; // System.out.println(arr1[0]); //情况二： // int[][] arr2 = new int[4][]; // System.out.println(arr2[0][0]); //情况三： String[] arr3 = new String[]{\"AA\",\"BB\",\"CC\"}; arr3[0] = null; System.out.println(arr3[0].toString());","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"Eclipse","slug":"Eclipse","date":"2021-01-12T14:04:56.000Z","updated":"2022-10-05T12:56:36.954Z","comments":true,"path":"2021/01/12/eclipse/","link":"","permalink":"http://fsh010816.github.io/2021/01/12/eclipse/","excerpt":"","text":"# Eclipse # 1. 结构 左侧： 结构 1： Package Explorer ​ 结构 2 ：Navigator ​ 结构 3：Outline 下面：结构 :4: Console # 2. 配置 # 2.1 字符 # 2.2 字体 # 2.3 修改 new 菜单 # 3.helloworld 先 new Java Project 在 src 下 new package 在包下 new class # 4. 导入工程 # 5. 提示功能 windows preferences . 改成 a-z. # 6. 快捷键设置 windows preferences 搜索 keys # 7. 快捷键 /* * Eclipse中的快捷键： * 1.补全代码的声明：alt + / * 2.快速修复: ctrl + 1 * 3.批量导包：ctrl + shift + o * 4.使用单行注释：ctrl + / * 5.使用多行注释： ctrl + shift + / * 6.取消多行注释：ctrl + shift + \\ * 7.复制指定行的代码：ctrl + alt + down 或 ctrl + alt + up * 8.删除指定行的代码：ctrl + d * 9.上下移动代码：alt + up 或 alt + down * 10.切换到下一行代码空位：shift + enter * 11.切换到上一行代码空位：ctrl + shift + enter * 12.如何查看源码：ctrl + 选中指定的结构 或 ctrl + shift + t * 13.退回到前一个编辑的页面：alt + left * 14.进入到下一个编辑的页面(针对于上面那条来说的)：alt + right * 15.光标选中指定的类，查看继承树结构：ctrl + t * 16.复制代码： ctrl + c * 17.撤销： ctrl + z * 18.反撤销： ctrl + y * 19.剪切：ctrl + x * 20.粘贴：ctrl + v * 21.保存： ctrl + s * 22.全选：ctrl + a * 23.格式化代码： ctrl + shift + f * 24.选中数行，整体往后移动：tab * 25.选中数行，整体往前移动：shift + tab * 26.在当前类中，显示类结构，并支持搜索指定的方法、属性等：ctrl + o * 27.批量修改指定的变量名、方法名、类名等：alt + shift + r * 28.选中的结构的大小写的切换：变成大写： ctrl + shift + x * 29.选中的结构的大小写的切换：变成小写：ctrl + shift + y * 30.调出生成getter/setter/构造器等结构： alt + shift + s * 31.显示当前选择资源(工程 or 文件)的属性：alt + enter * 32.快速查找：参照选中的Word快速定位到下一个 ：ctrl + k * * 33.关闭当前窗口：ctrl + w * 34.关闭所有的窗口：ctrl + shift + w * 35.查看指定的结构使用过的地方：ctrl + alt + g * 36.查找与替换：ctrl + f * 37.最大化当前的View：ctrl + m * 38.直接定位到当前行的首位：home * 39.直接定位到当前行的末位：end */ # 8.Java 中的 JUnit 单元测试 步骤： 1. 选中当前工程 - 右键选择：build path - add libraries - JUnit 4 - 下一步 2. 创建 Java 类，进行单元测试。 此时的 Java 类要求：① 此类是 public 的 ②此类提供公共的无参的构造器 3. 此类中声明单元测试方法。 此时的单元测试方法：方法的权限是 public, 没有返回值，没有形参 4. 此单元测试方法上需要声明注解：@Test, 并在单元测试类中导入：import org.junit.Test; 5. 声明好单元测试方法以后，就可以在方法体内测试相关的代码。 6. 写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test 说明： 1. 如果执行结果没有任何异常：绿条 2. 如果执行结果出现异常：红条","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"2_Java基本语法","slug":"2-Java基本语法","date":"2021-01-09T02:11:52.000Z","updated":"2022-10-18T10:43:05.703Z","comments":true,"path":"2021/01/09/2-java-ji-ben-yu-fa/","link":"","permalink":"http://fsh010816.github.io/2021/01/09/2-java-ji-ben-yu-fa/","excerpt":"","text":"# Java 基本语法 # 1. 关键字与保留字 # 1.1 关键字 定义：被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词） 特点：关键字中所有字母都为小写 # 1.2 保留字 Java 保留字：现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字 goto 、const # 2. 标识符 # 2.1 标识符 Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符 技巧：凡是自己可以起名字的地方都叫标识符 # 2.2 定义合法标识符规则： 由 26 个英文字母大小写，0-9 ，_或 $ 组成 数字不可以开头。 不可以使用关键字和保留字，但能包含关键字和保留字。 Java 中严格区分大小写，长度无限制。 标识符不能包含空格 # 2.3 Java 中的名称命名规范 包名：多单词组成时所有字母都小写：xxxyyyzzz 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ # 3. 变量 # 3.1 变量 内存中的一个存储区域 该区域的数据可以在同一类型范围内不断变化 变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值 作用：用于在内存中保存数据 # 3.2 注意 Java 中每个变量必须先声明，后使用 使用变量名来访问这块区域的数据 变量的作用域：其定义所在的一对 { } 内 变量只有在其作用域内才有效 同一个作用域内，不能定义重名的变量 # 3.3 声明 赋值 声明变量 语法：&lt;数据类型&gt; &lt; 变量名称 &gt; 例如：int var; 变量的赋值 语法：&lt;变量名称&gt; = &lt; 值 &gt; 例如：var = 10; 声明和赋值变量 语法： &lt;数据类型&gt; &lt; 变量名 &gt; = &lt; 初始化值 &gt; 例如：int var = 10; # 3.4 变量的分类 # 3.4.1 按数据类型 # 3.4.2 按声明的位置的不同 在方法体外，类体内声明的变量称为成员变量 。 在方法体内部声明的变量称为局部变量 。 ● 注意：二者在初始化值方面的异同: 同：都有生命周期 异：局部变量除形参外，需显式初始化 # 3.5 整数类型 java 的整型常量默认为 int 型，声明 long 型常量须后加‘l’或‘L’ long l1 = 123L; long l1 = 123;//没加L则是int型，自动提升为long # 3.6 浮点类型 浮点型常量有两种表示形式： ①十进制数形式：如：5.12 512.0f .512 (必须有小数点） ②科学计数法形式：如：5.12e2 512E2 100E-2 float: 单精度，尾数可以精确到 7 位有效数字。很多情况下，精度很难满足需求。 double: 双精度，精度是 float 的两倍。通常采用此类型。 Java 的浮点型常量默认为 double 型，声明 float 型常量，必须后加‘f’ 或‘F’ 。 float f1 = 12.3f; double d1 = 100E-2; System.out.println(d1);//结果为1.0 double d2 = .512; System.out.println(d2);//结果为0.512 float 表示数值的范围比 long 还大 # 3.7 字符类型 char 型数据用来表示通常意义上 “字符”(2 字节) Java 中的所有字符都使用 Unicode 编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。 char 类型是可以进行运算的。因为它都对应有 Unicode 码。 # 3.7.1 字符型变量的三种表现形式 字符常量是用单引号 (‘ ’) 括起来的单个字符。例如：char c1 = ‘a’; char c2= ‘中’; char c3 = ‘9’; Java 中还允许使用转义字符‘\\’来将其后的字符转变为特殊字符型常量。例如：char c3 = ‘\\n’; // '\\n’表示换行符 \"\\n\"也是换行 直接使用 Unicode 值来表示字符型常量：‘\\uXXXX’。其中，XXXX 代表一个十六进制整数。如：\\u000a 表示 \\n。 char c = 97;//开发中非常少见，输出的话是'a' # 3.8 布尔类型 Java 虚拟机中没有任何供 boolean 值专用的字节码指令，Java 语言表达所操作的 boolean 值，在编译之后都使用 java 虚拟机中的 int 数据类型来代替：true 用 1 表示，false 用 0 表示。 ———《java 虚拟机规范 8 版》 # 3.9 基本数据类型转换 # 3.9.1 自动类型转换 容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为： byte,short,char 之间不会相互转换，他们三者在计算时首先转换为 int 类型。 boolean 类型不能与其它数据类型运算。 当把任何基本数据类型的值和字符串 (String) 进行连接运算时 (+)，基本数据类型的值将自动转化为字符串 (String) 类型。 # 3.9.2 强制类型转换 强制转换符：() 通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。 boolean 类型不可以转换为其它的数据类型。 强制转换可能会导致精度降低或溢出 //精度损失例1 double d1 = 12.9; int i1 = (int) d1;//截断操作 System.out.println(i1);//12 //精度损失例2 int i2 = 128; byte b1 = (byte)i2; System.out.println(b1);//-128 二进制为1000 0000 # 3.10 字符串类型 使用方式与基本数据类型一致。例如：String str = “abcd”; 一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据。 String 可以和 8 种基本类型做运算，且运算只能是连接运算：+。运算的结果仍然是 String 类型 String s1 = \"\";//可以 char c1 = '';//不行 boolean b2 = true; String s1 = \"真\"; String s2 = s1 + b2;//+:连接运算 System.out.println(s2); //真true System.out.println('*' + '\\t' + '*'); //93 System.out.println('*' + \"\\t\" + '*');//* * System.out.println('*' + '\\t' + \"*\");//51* # 3.11 进制 二进制 (binary) ：0,1 ，满 2 进 1. 以 0b 或 0B 开头。 八进制 (octal) ：0-7 ，满 8 进 1. 以数字 0 开头表示。 十六进制 (hex) ：0-9 及 A-F，满 16 进 1. 以 0x 或 0X 开头表示 # 4. 运算符 运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。 算术运算符 赋值运算符 比较运算符（关系运算符） 逻辑运算符 位运算符 三元运算符 # 4.1 算术运算符 % 取余运算，结果的符号与被模数的符号相同 被模数 % 模数 自增 1 不会改变本身变量的数据类型 byte b1 = -128; b1--; System.out.println(b1); //127 # 4.2 赋值运算符 符号：= 支持连续赋值。 //连续赋值 int i = 10,j = 20; int i1,j1; i1 = j1 = 10; += 不会改变变量本身的数据类型 byte b1 = 127; b1 += 2; System.out.println(b1); //-127 int i2 = 1; i2 *= 0.1; System.out.println(i2);//0 int m = 2; int n = 3; n *= m++; // n = n * m++; System.out.println(\"m=\" + m); //3 System.out.println(\"n=\" + n);//6 int n1 = 10; n1 += (n1++) + (++n1); //n1 = n1 + (n1++) + (++n1); System.out.println(n1); //32 # 4.3 比较运算符 比较运算符的结果都是 boolean 型，也就是要么是 true，要么是 false。 instanceof 检查是否是类的对象 “Hello” instanceof String //true int i = 10; int j = 20; System.out.println(i = j);//20 &lt;&gt;&gt;= &lt;=: 只能用在数值类型的数据之间 ==：不仅可以使用在数值类型之间，还可以使用在其他引用类型变量之间 # 4.4 逻辑运算符 &amp;— 逻辑与 | — 逻辑或 ！— 逻辑非 &amp;&amp; — 短路与 || — 短路或 ^ — 逻辑异或 (不一样为 true) 逻辑运算符用于连接布尔型表达式 “&amp;” 和 “&amp;&amp;” 的区别： ①: 单 &amp; 时，左边无论真假，右边都进行运算； ②: 双 &amp; 时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。 开发中，推荐使用 &amp;&amp; # 4.5 位运算符 位运算是直接对整数的二进制进行的运算 # 4.5.1 交换两个变量的值 //交换两个变量的值 int num1 = 10; int num2 = 20; System.out.println(\"num1=\"+num1+\",num2=\"+num2); //方式一：定义临时变量 int temp; temp = num1; num1 = num2; num2 = temp; //方式二： 好处：不用定义临时变量 //弊端：①相加可能超出范围 ②有局限性：只能适用于数值类型 // num1 = num1 + num2; // num2 = num1 - num2; // num1 = num1 - num2; //方式三：使用位运算符 //局限性：只能用于数值 // num1 = num1 ^ num2; // num2 = num1 ^ num2; // num1 = num1 ^ num2; System.out.println(\"num1=\"+num1+\",num2=\"+num2); # 4.6 三元运算符 (条件表达式)? 表达式 1 ：表达式 2 表达式 1 和表达式 2 要求是一致的 int m = 12; int n = 5; double num = (m &gt; n) ? 2 : 1.0; System.out.println(num);//2.0 三元运算符可以嵌套使用 凡是可以使用三元运算符的地方，都可以改写成 if-else。反之，不成立 如果三元和 if-else 都能用，优先三元，原因：简洁、执行效率高 # 4.7 运算符的优先级 只有单目运算符、三元运算符、赋值运算符是从右向左运算的。 # 5. 程序流程控制 顺序结构 分支结构 循环结构 # 5.1 if-else 结构 if 语句三种格式 ① if (条件表达式){ 执行表达式； } ② 二选一 if (条件表达式){ 执行表达式 1; }else{ 执行表达式 2; } ③ 多选一 if (条件表达式 1){ 执行表达式 1; } else if (条件表达式 2){ 执行表达式 2; } …… else{ 执行表达式 n; } 注意：当多个条件是 “互斥” 关系时，条件判断语句及执行语句间顺序无所谓 当多个条件是 “包含” 关系时，“小上大下 / 子上父下” int x = 4; int y = 1; if (x &gt; 2) if (y &gt; 2) System.out.println(x + y); else System.out.println(\"x is \" + x); //else找if就近原则 # 5.1.1 随机数 Math.random () [0.0,1.0) double 型的 //10-99的随机数 int value = (int) (Math.random() * 90 + 10);//[0.0,1.0)--&gt;[0.0,90.0)--&gt;[10.0,100.0)--&gt;[10,99] //公式：[a,b]:(int)(Math.random() * (b - a + 1) + a) # 5.2 Scanner 1 &gt; 导包 import java.util.Scanner; 2&gt;Scanner 的实例化 Scanner scan = new Scanner(System.in); 3 &gt; 调用 Scanner 类的相关方法，来获取指定类型的变量 int num = scan.nextInt(); 对于 char 型的获取，Scanner 没有提供相应的方法 String s1 = \"hello\"; System.out.println(s1.charAt(0)); //h 获取索引为0位置上的字符 # 5.3 switch-case switch(表达式){ case 常量1: 语句1; // break; case 常量2: 语句2; // break; … … case 常量N: 语句N; // break; default: 语句; // break; } 1&gt;break 语句用来在执行完一个 case 分支后使程序跳出 switch 语句块；如果没有 break，程序会顺序执行到 switch 结尾 则继续向下执行其他 case 结构中的执行语句，直到遇到 break 或此 switch-case 结构末尾结束为止 2&gt;switch (表达式) 中表达式的值 必须是下述几种类型之一：byte ，short,char ，int， 枚举 (jdk 5.0) ，String (jdk 7.0)； 3&gt; default 子句是可任选的。同时，位置也是灵活的。当没有匹配的 case 时，执行 default 4 &gt; 如果 switch-case 结构中的多个 case 执行语句相同，则可以考虑进行合并 5 &gt; 在 switch-case 的括号里定义的变量，出了括号不能调用，在括号内只能定义一次（不同的 case 不能定义同名变量）。 6&gt;case 子句中的值必须是常量，不能是变量名或不确定的表达式值； 7 &gt; 同一个 switch 语句，所有 case 子句中的常量值互不相同 (if-else 的条件表达式可以相同)； 说明：凡是可以使用 switch-case 的结构，都可以转换为 if-else。反之，不成立。 我们写分支结构时，既可以使用 switch-case（同时，switch 中表达式的取值情况不太多），又可以使用 if-else 时，优先选择使用 switch-case。原因：switch-case 执行效率稍高 # 5.4 循环结构 for 循环 while 循环 do-while 循环 循环语句的四个组成部分 ①初始化部分 (init_statement) ②循环条件部分 (test_exp) boolean 类型 ③循环体部分 (body_statement) ④迭代部分 (alter_statement) 结束循环：①循环条件部分返回 false②循环体中，执行 break # 5.4.1 for 循环 for (①初始化部分; ②循环条件部分; ④迭代部分)｛ ③循环体部分; ｝ ①初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔 (int i = 1,j=1; 连续赋值) ④可以有多个变量更新，用逗号分隔 class ForTest{ public static void main(String[] args){ int sum; for(int i=1;i&lt;=100;i++){ if(1%2!=0){ System.out.println(i); sum=i; }else{ sum=1; } } System.out.println(sum); } } 错误：可能尚未初始化变量sum # 5.4.2 while 循环 ①初始化部分 while (②循环条件部分)｛ ③循环体部分； ④迭代部分； } for 和 whilel 可以相互转换 for 和 while 区别：初始化条件部分的作用范围不同 # 5.4.3 do-while ①初始化部分； do{ ③循环体部分 ④迭代部分 } while (②循环条件部分); do-while 循环至少执行一次循环体 # 5.4.4 最简单 “无限” 循环 最简单 “无限” ” 循环： 格式： while(true) for(;;) 无限循环存在的原因是并不知道循环多少次， 需要根据循环体内部某些条件，来控制循环的结束 # 5.4.5 嵌套循环 内层循环结构遍历一遍，只相当于外层循环循环体执行了一次 外层循环控制行数，内层循环控制列数 # 5.4.5.1 100 内的质数 public static void main(String[] args) { //优化 boolean isFlag = true; //标识i是否被j除尽，除尽则修改其值 for (int i = 2; i &lt;= 100; i++) { //遍历2到100 //j &lt;= Math.sqrt(i) 优化二：对本身是质数的自然数是有效的 for (int j = 2; j &lt;= Math.sqrt(i); j++) { if (i%j==0){//i被j除尽 isFlag=false; break;//优化一：只对本身非质数的自然数有效 } } if (isFlag==true){ System.out.println(i); } //重置isFlag isFlag=true; } } public static void main(String[] args) { label:for (int i = 2; i &lt;= 100; i++) { //遍历2到100 for (int j = 2; j &lt;= Math.sqrt(i); j++) { if (i%j==0){//i被j除尽 continue label; } } System.out.println(i); } } # 5.4.6 currentTimeMillis() long start=System.currentTimeMillis();//当前的时间到1970年...的毫秒数 # 5.4.7 break continue break 语句用于终止某个语句块的执行，结束当前循环 { …… break; …… } continue 语句用于跳过其所在循环语句块的一次执行，继续下一次循环，结束当次循环 两个关键字后面都不能声明执行语句，会报错 continue 是终止本次循环，break 是终止本层循环 1&gt;break 只能用于 switch 语句和循环语句中。 2&gt;continue 只能用于循环语句中。 都是用于最近的一次循环 # 5.4.8 label class LabelTest{ public static void main(String[] args){ label:for (int i = 1; i &lt;= 4; i++) { for (int j = 1; j &lt;= 10; j++) { if (j % 4==0){ // break; /* 123 123 123 123 */ // continue; /* 123567910 123567910 123567910 123567910 */ // break label; //123 continue label; //123123123123 } System.out.print(j); } System.out.println(); } } } # 5.4.9 return return：并非专门用于结束循环的，它的功能是结束一个方法。当一个方法执行到一个 return 语句时，这个方法将被结束。 与 break 和 continue 不同的是，return 直接结束整个方法，不管这个 return 处于多少层循环之内","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"1_Java语言概述","slug":"1-Java语言概述","date":"2021-01-08T11:52:47.000Z","updated":"2022-10-18T03:26:01.549Z","comments":true,"path":"2021/01/08/1-java-yu-yan-gai-shu/","link":"","permalink":"http://fsh010816.github.io/2021/01/08/1-java-yu-yan-gai-shu/","excerpt":"","text":"# Java 语言概述 # 1. 常用的命令行指令 echo javase&gt;1.doc 创建 1.doc，内容是 javase # 2. 前端、后端、前台、后台的区别 # 3.JDK JRE ・JDK = JRE + 开发工具集（例如 Javac 编译工具等） ・JRE = JVM + Java SE 标准类库 # 3.1 JDK JDK (Java Development Kit Java 开发工具包) JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE 了。其中的开发工具：编译工具 (javac.exe) 打包工具 (jar.exe) 等 # 3.2 JRE JRE (Java Runtime Environment Java 运行环境) 包括 Java 虚拟机 (JVM Java Virtual Machine) 和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可 JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。 简单而言，使用 JDK 的开发工具完成的 java 程序，交给 JRE 去运行。 # 4.JDK 安装 安装时会跳出安装 jre。 # 4.1 环境变量 path：windows 系统执行命令时要搜寻的路径。 JAVA_HOME:bin 的上一层目录 path:%JAVA_HOME%\\bin # 5. 第一个 Java 程序 字节码文件名是类名 有了 java 源文件，通过编译器将其编译成 JVM 可以识别的字节码文件。 # 6. 注释 1.// 单行 /* 多行 */ /** 文档注释 */ 注释内容可以被 JDK 提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。 javadoc -encoding UTF-8 -charset UTF-8 -d myHello -author -version HelloJava.java //myHello是要生成的文件夹的名字 # 7.API API （Application Programming Interface, 应用程序编程接口）是 Java 提供的基本编程接口。 # 8. 总结 1. 在一个 Java 源文件中可以声明多个 class, 只能有一个声明为 public 的，而且声明为 public 的类的类命必须与源文件名相同。 2. 程序的入口是 main 方法 3. 编译后，会生成一个或多个字节码文件，字节码文件的文件名与 Java 源文件中的类名相同 4. 编译：javac 源文件名.java 运行：java 类名 # 9.IDE Integrated Development Environment 集成开发环境 # 10.Java 两种核心机制 Java 虚拟机 垃圾收集机制","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-12-18T12:06:13.968Z","updated":"2020-12-18T12:06:13.968Z","comments":true,"path":"2020/12/18/hello-world/","link":"","permalink":"http://fsh010816.github.io/2020/12/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. # Quick Start # Create a new post $ hexo new \"My New Post\" More info: Writing # Run server $ hexo server More info: Server # Generate static files $ hexo generate More info: Generating # Deploy to remote sites $ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://fsh010816.github.io/tags/JavaSE/"}]}